#!/bin/sh

# TODO: https://gitlab.com/tezos/tezos/-/issues/6638
#       Currently, we fix e2e testing to Javascript runtime (parse_and_print.js).
#       As the project evolves we may want to support more target environments.
#       This could be solved by --target-language and --target-script-path
#       parameters.

# TODO: https://gitlab.com/tezos/tezos/-/issues/6666
#       The script is generally very verbose. We may want to add logging levels.

set -u

if [ -n "${TRACE:-}" ]; then set -x; fi

usage() {
  cat << EOF
Usage: $0 KSY_DIR HEX_INPUT_DIR

$(basename "$0") is a script used for e2e testing of kaitai struct files.

Arguments:
KSY_DIR                 Directory with kaitai struct files (.ksy files) to be
                        validated.
HEX_INPUT_DIR           Directory with test inputs for .ksy files inside KSY_DIR.
                        It should consist of "valid" and "invalid" sub-directories.

                        For every .ksy file inside KSY_DIR/[encoding].ksy,
                        script expects the following entries:
                        - HEX_INPUT_DIR/valid/[encoding]/*.hex (valid input).
                        - HEX_INPUT_DIR/invvalid/[encoding]/*.hex (invalid input).

The e2e test consist of the following steps:
1. For every kaitai struct specification file (.ksy file), we first
   generate a valid parser in Javascript using "kaitai-struct-compiler".
2. For every autogenerated parser from 1., we test that it succeeds parsing
   corresponding valid binary blobs and fails parsing invalid binary blobs.

DEPENDENCIES:
- We expect "node" and "npm" to be installed and part of the "PATH".
- "kaitai-struct-compiler": E.g. see https://github.com/kaitai-io/kaitai_struct_compiler.
- Kaitai Javascript runtime environment: E.g. run "npm i".
- parse_and_print.js script that should be located in the same directory as
  $(basename "$0"). This script loads autogenerated Javascript parser and tries
  to parse and print corresponding sample inputs.
EOF
  exit 1
}

if [ "${1:-}" = "--help" ] || [ $# != 2 ]; then
  usage
fi

indent_output() {
  num_spaces=$1
  spaces=$(printf ' %.0s' $(seq 1 "$num_spaces"))
  sed "s/^/${spaces}/" >&2
}

log_with_ident() {
  echo "$2" | indent_output "$1"
}

log() {
  echo "$1" >&2
}

# This is needed since we generate parsers inside /tmp, that depend on the local
# installation of `kaitai-struct` module.
current_dir="$(pwd)"
export NODE_PATH="$current_dir/node_modules"
# Test for dependencies
kaitai_struct_package=kaitai-struct@0.10.0
kaitai_struct_module=kaitai-struct
commands="find xxd npm node kaitai-struct-compiler"
if ! npm list kaitai-struct@0.10.0 | grep kaitai-struct@0.10.0 > /dev/null; then
  echo "$kaitai_struct_package (npm package) is missing."
  exit 1
fi
# Parsers are generated inside /tmp directory and require to have access
# to `kaitai-struct` node module. We make explicit check for this scenario here.
if ! (cd /tmp && node -e "require.resolve('$kaitai_struct_module')" > /dev/null 2>&1); then
  echo "\"$kaitai_struct_module\" module is not found."
  exit 1
fi
for cmd in $commands; do
  if ! command -v "$cmd" > /dev/null 2>&1; then
    echo "Command not found: $cmd"
    exit 1
  fi
done

DIR=$(dirname "$0")
PARSE_AND_PRINT="$DIR/parse_and_print.js"
KSY_DIR="$1"
HEX_INPUT_DIR="$2"

# Create a temporary directory
tmp=$(mktemp -d)

# ignore this problem because the command is
# called in a trap: https://www.shellcheck.net/wiki/SC2317
# shellcheck disable=SC2317
cleanup() {
  rm -rf "${tmp}"
  exit
}

# Register a cleanup.
trap cleanup EXIT INT

parse_hex_input() {
  hex_file=$1
  encoding=$2
  parser=$3
  valid=$4
  input_filename="$(basename "$hex_file" .hex)"
  bin_file=$(mktemp --tmpdir="${tmp}" --suffix ".${encoding}.${input_filename}.bin")
  xxd -r -p < "$hex_file" > "$bin_file"
  if $valid; then
    log "Running validation of $encoding using valid '$input_filename.hex' input."
    log "Parsing and printing should succeed."
  else
    log "Running validation of $encoding using invalid '$input_filename.hex' input."
    log "Parsing and printing should fail. You should see error log below."
  fi
  log "Bin file path: $bin_file"
  log "Hex input for testing ${encoding}'s autogenerated parser: "
  log_with_ident 4 "$(cat "$hex_file")"
  log "Binary input for testing ${encoding}'s autogenerated parser: "
  log_with_ident 4 "$(xxd -b: < "${bin_file}")"
  # To test semantic correctness of autogenerated javascript parser, we load
  # the parser, parse the binary input with it, and print it to console.
  node "$PARSE_AND_PRINT" "$parser" "$bin_file" "$valid"
}

dir_has_hex_files() {
  find "${1}"/*.hex -maxdepth 0 -type f > /dev/null 2>&1
}

validate_kaitai_spec() {
  encoding=$1
  valid_input=$2
  invalid_input=$3
  ksy_file="${KSY_DIR}/${encoding}.ksy"
  # kaitai-struct-compiler gives an auto-generated file a random name.
  # In order to get this filename at runtime, we
  # create a dummy `tmp/*/parser/${encoding}/` dir
  # and get an autogenerated file assuming that this
  # directory contains only one file.
  parser_dir="${tmp}/parsers/${encoding}"
  mkdir -p "$parser_dir"
  kaitai-struct-compiler "$ksy_file" -t javascript --outdir "$parser_dir"
  parser_path="$(find "$parser_dir" -type f | head -n 1)"
  log "ksy file we are testing:"
  log_with_ident 4 "$(cat "$ksy_file")"
  log "Autogenerated parser from ${encoding}'s ksy file:"
  log_with_ident 4 "$(cat "$parser_path")"
  for hex_file in "$valid_input"/*; do
    # We have tested above valid input dir is not empty.
    parse_hex_input "$hex_file" "$encoding" "$parser_path" true
    validation_status=$?
    if [ $validation_status != 0 ]; then
      log "$encoding: Autogenerated parser fails to parse valid binary blob."
      return 1
    fi
  done
  for hex_file in "$invalid_input"/*; do
    if [ ! -f "$hex_file" ]; then
      # No invalid input files => nothing to test.
      return 0
    fi
    parse_hex_input "$hex_file" "$encoding" "$parser_path" false
    validation_status=$?
    if [ $validation_status != 0 ]; then
      log "$encoding: Autogenerated parser parses invalid(!) binary blob."
      return 1
    fi
  done
}

valid=0
invalid=0
untested=0
total=0
for ksy_file in "$KSY_DIR"/*.ksy; do
  encoding="$(basename "$ksy_file" .ksy)"
  valid_input_dir="${HEX_INPUT_DIR}/valid/${encoding}"
  invalid_input_dir="${HEX_INPUT_DIR}/invalid/${encoding}"
  total=$((total += 1))
  log "Running validation of $ksy_file:"
  if ! dir_has_hex_files "$valid_input_dir"; then
    log_with_ident 4 "- Aborting validation of \"$encoding\" due to missing valid input files."
    log_with_ident 4 "- To fix this add at least one valid \".hex\" file inside: \"$valid_input_dir\"."
    untested=$((untested + 1))
    continue
  fi
  # Emit warning if no corresponding invalid input files.
  if ! dir_has_hex_files "$invalid_input_dir"; then
    log_with_ident 4 "- WARNING: \"$encoding\" has no coresponding invalid input files."
    log_with_ident 4 "- To fix this add at least one invalid \".hex\" file inside: \"$invalid_input_dir\"."
  fi
  validation_output=$(validate_kaitai_spec "$encoding" "$valid_input_dir" "$invalid_input_dir" 2>&1)
  validation_status=$?
  if [ $validation_status -eq 0 ]; then
    valid=$((valid + 1))
    log_with_ident 4 "$encoding kaitai spec file is valid."
  else
    log_with_ident 4 "$encoding kaitai spec files is not valid."
    log_with_ident 4 "See the action log:"
    log_with_ident 8 "$validation_output"
    invalid=$((invalid + 1))
  fi
done
cat << EOF
VALIDATION RESULTS:
    - $valid/$total are semantically valid.
    - $invalid/$total are semantically invalid.
    - $untested/$total are not tested due to a missing input files.
EOF

# This command succeeds unless semantically invalid files are found.
# Having untested files is fine for now.
if [ $((valid + untested)) -eq $total ]; then
  exit 0
else
  exit 1
fi
