//****************************************************************************//
//                                                                            //
// SPDX-License-Identifier: MIT                                               //
// Copyright (c) [2023] Serokell <hi@serokell.io>                             //
//                                                                            //
//****************************************************************************//

#![allow(dead_code)]
use std::str::FromStr;
use lalrpop_util::ParseError;

use crate::ast::*;
use crate::parser::validate_unescape_string;

grammar;

match {
  r"(?-u:\s)+" => {}, // more or less same as default, but required to build w/o unicode
  _
}

number: i128 = <s:r"([+-]?)[0-9]+"> =>? i128::from_str(s)
  .map_err(|_| ParseError::User { error : "parsing of numeric literal failed." } );

u10: u16 = <s:r"([+-]?)[0-9]+"> =>? {
    let res = u16::from_str(s)
      .map_err(|_| ParseError::User { error : "Expected a natural from 0 to 1023 inclusive" } )?;
    if res >= 1024 {
      return Err(ParseError::User {
        error: "Expected a natural from 0 to 1023 inclusive"
      });
    }
    Ok(res)
  };

pub string: String = <r#""(?:\\.|[^\\"])*""#> =>? validate_unescape_string(<>);

type_: Type = {
  "int"  => Type::Int,
  "nat"  => Type::Nat,
  "bool" => Type::Bool,
  "mutez" => Type::Mutez,
  "string" => Type::String,
}

boolean: bool = {
  "True" => true,
  "False" => false,
}

use Value::*;
value: Value = {
  <n:number> => NumberValue(n),
  <b:boolean> => BooleanValue(b),
  <string> => StringValue(<>),
}

use Instruction::*;
instruction: ParsedInstruction = {
  "PUSH" <t:type_> <v:value> => Push(t, v),
  "INT" => Int,
  "GT" => Gt,
  "LOOP" <ib: instructionBlock> => Loop(ib),
  "DIP" <n:u10?> <ib: instructionBlock> => Dip(n, ib),
  "ADD" => Add(()),
  "DROP" <n:u10?> => Drop(n),
  "SWAP" => Swap,
  "IF" <t: instructionBlock> <f: instructionBlock> => If(t, f),
  "DUP" <n:u10?> => Dup(n),
  "FAILWITH" => Failwith,
}

instructionSeq: Vec<ParsedInstruction> = {
  <mut ib:(<instruction>";")*><i:instruction?> => {
    // A sequence of instruction-followed-by-a-semicolon matched by
    // `(<instruction>";")*` resulting in `Vec<instruction>` and bound to `ib`,
    // which can be optionally followed by a single trailing instruction,
    // matched by `<i:instruction?>.

    match i {
      Some(instr) => {
        ib.push(instr);
        ib
      },
      None => {
        ib
      }
    }
  }
}

pub instructionBlock: ParsedInstructionBlock = {
  "{" <is:instructionSeq> "}" => is,
}
