(*****************************************************************************)
(*                                                                           *)
(* SPDX-License-Identifier: MIT                                              *)
(* SPDX-FileCopyrightText: 2022-2023 TriliTech <contact@trili.tech>          *)
(* SPDX-FileCopyrightText: 2022 Marigold <contact@marigold.dev>              *)
(* SPDX-FileCopyrightText: 2025 Nomadic Labs <contact@nomadic-labs.com>      *)
(*                                                                           *)
(*****************************************************************************)

module State_in_memory = struct
  module Context = Tezos_context_memory.Context_binary

  type context = Context.context

  type Tezos_tree_encoding.tree_instance += PVM_tree of Context.tree

  module Wrapped_tree = struct
    include Context.Tree

    type tree = Context.tree

    let select = function
      | PVM_tree t -> t
      | _ -> raise Tezos_tree_encoding.Incorrect_tree_type

    let wrap t = PVM_tree t
  end

  include Tezos_scoru_wasm.Tree_state.Make (Wrapped_tree)

  let empty_state () = Context.make_empty_context () |> Wrapped_tree.empty

  let state_hash tree =
    Context.Tree.hash tree
    |> Tezos_crypto.Hashed.Smart_rollup_state_hash.context_hash_to_state_hash
    |> Lwt.return

  type proof = Context.Proof.(tree t)

  let proof_encoding =
    Tezos_context_merkle_proof_encoding.Merkle_proof_encoding.V2.Tree2
    .tree_proof_encoding

  let kinded_hash_to_state_hash = function
    | `Value hash | `Node hash ->
        Tezos_crypto.Hashed.Smart_rollup_state_hash.context_hash_to_state_hash
          hash

  let proof_start_state proof =
    kinded_hash_to_state_hash proof.Context.Proof.before

  let proof_stop_state proof =
    kinded_hash_to_state_hash proof.Context.Proof.after

  let cast_read_only proof = Context.Proof.{proof with after = proof.before}

  let produce_proof context tree step =
    let open Lwt_syntax in
    let* context = Context.add_tree context [] tree in
    let* _hash = Context.commit ~time:Time.Protocol.epoch context in
    let index = Context.index context in
    match Context.Tree.kinded_key tree with
    | Some k ->
        let* p = Context.produce_tree_proof index k step in
        return_some p
    | None -> return_none

  type error += Expected_binary_proof

  let () =
    register_error_kind
      `Permanent
      ~id:"Expected_binary_proof"
      ~title:"Expected binary proof"
      ~description:"An invalid proof has been submitted"
      Data_encoding.empty
      (function Expected_binary_proof -> Some () | _ -> None)
      (fun () -> Expected_binary_proof)

  (* TODO: https://gitlab.com/tezos/tezos/-/issues/4386 Extracted and
   adapted from {!Tezos_context_memory}. Ideally, this function should
   be exported there.

   In a nutshell, the context library exposed by the environment is
   implemented such that it can verify proofs generated by both
   [Context] and [Context_binary], and the only thing that
   differentiate these proofs from its perspective is the second bit
   of the [version] field of the proof.

   To ensure we only consider proofs computed against a binary tree,
   we check said bit. This prevents a 32-ary proof to be accepted by
   the protocol in the case where a given key-value store has the same
   hash with both [Context] and [Context_binary] (something that
   happens when the tree contains only one entry). *)
  let check_is_binary proof =
    let extract_bit v mask = Compare.Int.(v land mask <> 0) in
    let binary_mask = 0b10 in
    let is_binary = extract_bit proof.Context.Proof.version binary_mask in
    error_unless is_binary Expected_binary_proof

  let verify_proof p f =
    let open Lwt_option_syntax in
    let*? () = Result.to_option (check_is_binary p) in
    Lwt.map Result.to_option (Context.verify_tree_proof p f)
end

module Wasm_pvm_in_memory :
  Tezos_scoru_wasm.Wasm_pvm_sig.S
    with type context = State_in_memory.context
     and type state = State_in_memory.state
     and type proof = State_in_memory.proof =
  Tezos_scoru_wasm.Wasm_pvm.Make_pvm_machine (State_in_memory)
