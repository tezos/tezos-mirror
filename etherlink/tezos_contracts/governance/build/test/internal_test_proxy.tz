{ parameter unit ;
  storage unit ;
  code { CDR ; NIL operation ; PAIR } ;
  view "get_kernel_upgrade_payload"
       (pair (bytes %kernel_root_hash) (timestamp %activation_timestamp))
       bytes
       { LAMBDA
           (pair nat nat)
           bytes
           { UNPAIR ;
             PUSH nat 56 ;
             DUP 2 ;
             COMPARE ;
             LT ;
             IF { ADD ; BYTES }
                { BYTES ;
                  DUP ;
                  SIZE ;
                  PUSH nat 9 ;
                  DUP 2 ;
                  COMPARE ;
                  LT ;
                  IF {} { PUSH string "INPUT_TOO_LONG_FOR_RLP" ; FAILWITH } ;
                  PUSH nat 55 ;
                  DIG 3 ;
                  DIG 2 ;
                  ADD ;
                  ADD ;
                  BYTES ;
                  CONCAT } } ;
         SWAP ;
         CAR ;
         UNPAIR ;
         PUSH nat 33 ;
         DUP 2 ;
         SIZE ;
         COMPARE ;
         EQ ;
         IF {} { PUSH string "INCORRECT_KERNEL_ROOT_HASH_LENGTH" ; FAILWITH } ;
         PUSH timestamp 0 ;
         DIG 2 ;
         SUB ;
         ISNAT ;
         PUSH string "NEGATIVE_TIMESTAMP" ;
         SWAP ;
         IF_NONE { FAILWITH } { SWAP ; DROP } ;
         BYTES ;
         PUSH bytes 0x ;
         PUSH int 1 ;
         PUSH int 1 ;
         DUP 4 ;
         SIZE ;
         SUB ;
         PUSH int 0 ;
         DUP 2 ;
         DUP 2 ;
         COMPARE ;
         LE ;
         LOOP { DUP ;
                DUG 3 ;
                DIP 3
                    { ISNAT ;
                      PUSH string "INDEX_NOT_NAT" ;
                      SWAP ;
                      IF_NONE { FAILWITH } { SWAP ; DROP } ;
                      SWAP ;
                      DUP 3 ;
                      PUSH nat 1 ;
                      DIG 3 ;
                      SLICE ;
                      IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
                      CONCAT } ;
                DUP 3 ;
                ADD ;
                DUP 2 ;
                DUP 2 ;
                COMPARE ;
                LE } ;
         DROP 3 ;
         SWAP ;
         DROP ;
         DUP ;
         SIZE ;
         INT ;
         PUSH int 1 ;
         PUSH int 1 ;
         PUSH nat 8 ;
         SUB ;
         DIG 2 ;
         DUP 2 ;
         DUP 2 ;
         COMPARE ;
         LE ;
         LOOP { DUP ;
                DUG 3 ;
                DIP 3 { DROP ; PUSH bytes 0x00 ; SWAP ; CONCAT } ;
                DUP 3 ;
                ADD ;
                DUP 2 ;
                DUP 2 ;
                COMPARE ;
                LE } ;
         DROP 3 ;
         NIL bytes ;
         SWAP ;
         CONS ;
         SWAP ;
         CONS ;
         MAP { DUP ;
               SIZE ;
               PUSH bytes 0x80 ;
               DUP 3 ;
               COMPARE ;
               LT ;
               PUSH nat 1 ;
               DUP 3 ;
               COMPARE ;
               EQ ;
               AND ;
               IF { DROP ; PUSH bytes 0x }
                  { PUSH nat 128 ; SWAP ; PAIR ; DUP 3 ; SWAP ; EXEC } ;
               CONCAT } ;
         PUSH bytes 0x ;
         SWAP ;
         NIL bytes ;
         SWAP ;
         ITER { CONS } ;
         ITER { CONCAT } ;
         PUSH nat 192 ;
         DUP 2 ;
         SIZE ;
         PAIR ;
         DIG 2 ;
         SWAP ;
         EXEC ;
         CONCAT } ;
  view "get_sequencer_upgrade_payload"
       (pair (string %sequencer_pk)
             (bytes %pool_address)
             (timestamp %activation_timestamp))
       bytes
       { LAMBDA
           (pair nat nat)
           bytes
           { UNPAIR ;
             PUSH nat 56 ;
             DUP 2 ;
             COMPARE ;
             LT ;
             IF { ADD ; BYTES }
                { BYTES ;
                  DUP ;
                  SIZE ;
                  PUSH nat 9 ;
                  DUP 2 ;
                  COMPARE ;
                  LT ;
                  IF {} { PUSH string "INPUT_TOO_LONG_FOR_RLP" ; FAILWITH } ;
                  PUSH nat 55 ;
                  DIG 3 ;
                  DIG 2 ;
                  ADD ;
                  ADD ;
                  BYTES ;
                  CONCAT } } ;
         SWAP ;
         CAR ;
         UNPAIR 3 ;
         DUP ;
         SIZE ;
         PUSH nat 55 ;
         DUP 2 ;
         COMPARE ;
         EQ ;
         PUSH nat 54 ;
         DIG 2 ;
         COMPARE ;
         EQ ;
         OR ;
         IF {} { PUSH string "INCORRECT_SEQUENCER_PK_LENGTH" ; FAILWITH } ;
         PUSH nat 20 ;
         DUP 3 ;
         SIZE ;
         COMPARE ;
         EQ ;
         IF {} { PUSH string "INCORRECT_POOL_ADDRESS_LENGTH" ; FAILWITH } ;
         PACK ;
         DUP ;
         PUSH nat 4 ;
         PUSH nat 2 ;
         SLICE ;
         IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
         NAT ;
         PUSH timestamp 0 ;
         DIG 4 ;
         SUB ;
         ISNAT ;
         PUSH string "NEGATIVE_TIMESTAMP" ;
         SWAP ;
         IF_NONE { FAILWITH } { SWAP ; DROP } ;
         BYTES ;
         PUSH bytes 0x ;
         PUSH int 1 ;
         PUSH int 1 ;
         DUP 4 ;
         SIZE ;
         SUB ;
         PUSH int 0 ;
         DUP 2 ;
         DUP 2 ;
         COMPARE ;
         LE ;
         LOOP { DUP ;
                DUG 3 ;
                DIP 3
                    { ISNAT ;
                      PUSH string "INDEX_NOT_NAT" ;
                      SWAP ;
                      IF_NONE { FAILWITH } { SWAP ; DROP } ;
                      SWAP ;
                      DUP 3 ;
                      PUSH nat 1 ;
                      DIG 3 ;
                      SLICE ;
                      IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
                      CONCAT } ;
                DUP 3 ;
                ADD ;
                DUP 2 ;
                DUP 2 ;
                COMPARE ;
                LE } ;
         DROP 3 ;
         SWAP ;
         DROP ;
         DUP ;
         SIZE ;
         INT ;
         PUSH int 1 ;
         PUSH int 1 ;
         PUSH nat 8 ;
         SUB ;
         DIG 2 ;
         DUP 2 ;
         DUP 2 ;
         COMPARE ;
         LE ;
         LOOP { DUP ;
                DUG 3 ;
                DIP 3 { DROP ; PUSH bytes 0x00 ; SWAP ; CONCAT } ;
                DUP 3 ;
                ADD ;
                DUP 2 ;
                DUP 2 ;
                COMPARE ;
                LE } ;
         DROP 3 ;
         NIL bytes ;
         SWAP ;
         CONS ;
         DIG 3 ;
         CONS ;
         DUG 2 ;
         PUSH nat 6 ;
         SLICE ;
         IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
         CONS ;
         MAP { DUP ;
               SIZE ;
               PUSH bytes 0x80 ;
               DUP 3 ;
               COMPARE ;
               LT ;
               PUSH nat 1 ;
               DUP 3 ;
               COMPARE ;
               EQ ;
               AND ;
               IF { DROP ; PUSH bytes 0x }
                  { PUSH nat 128 ; SWAP ; PAIR ; DUP 3 ; SWAP ; EXEC } ;
               CONCAT } ;
         PUSH bytes 0x ;
         SWAP ;
         NIL bytes ;
         SWAP ;
         ITER { CONS } ;
         ITER { CONCAT } ;
         PUSH nat 192 ;
         DUP 2 ;
         SIZE ;
         PAIR ;
         DIG 2 ;
         SWAP ;
         EXEC ;
         CONCAT } ;
  view "address_to_key_hash"
       address
       key_hash
       { CAR ;
         DUP ;
         PACK ;
         PUSH bytes 0x00 ;
         DUP 2 ;
         PUSH nat 1 ;
         PUSH nat 6 ;
         SLICE ;
         IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
         COMPARE ;
         EQ ;
         IF {} { PUSH string "NOT_IMPLICIT_ADDRESS" ; FAILWITH } ;
         PUSH bytes 0x ;
         NIL bytes ;
         DUP 3 ;
         PUSH nat 21 ;
         PUSH nat 7 ;
         SLICE ;
         IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
         CONS ;
         PUSH bytes 0x00000015 ;
         CONS ;
         DIG 2 ;
         PUSH nat 2 ;
         PUSH nat 0 ;
         SLICE ;
         IF_NONE { PUSH string "SLICE" ; FAILWITH } {} ;
         CONS ;
         NIL bytes ;
         SWAP ;
         ITER { CONS } ;
         ITER { CONCAT } ;
         UNPACK key_hash ;
         PUSH string "FAILED_TO_CAST_ADDRESS_TO_KEY_HASH" ;
         SWAP ;
         IF_NONE { FAILWITH } { SWAP ; DROP } ;
         PUSH string "KEY_HASH_NOT_EQUAL_TO_SOURCE_ADDRESS" ;
         DIG 2 ;
         DUP 3 ;
         IMPLICIT_ACCOUNT ;
         ADDRESS ;
         COMPARE ;
         EQ ;
         IF { DROP } { FAILWITH } } }

