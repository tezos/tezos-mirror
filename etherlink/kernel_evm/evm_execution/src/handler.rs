// SPDX-FileCopyrightText: 2022-2024 TriliTech <contact@trili.tech>
// SPDX-FileCopyrightText: 2023-2024 Functori <contact@functori.com>
//
// SPDX-License-Identifier: MIT

//! Handle details of EVM runtime
//!
//! The interface between SputnikVM and the kernel. This includes interface
//! to storage, account balances, block constants, _and transaction state_.

use crate::access_record::AccessRecord;
use crate::account_storage::{
    account_path, AccountStorageError, EthereumAccount, EthereumAccountStorage,
    CODE_HASH_DEFAULT,
};
use crate::transaction::TransactionContext;
use crate::EthereumError;
use crate::PrecompileSet;
use crate::{storage, tick_model_opcodes};
use alloc::borrow::Cow;
use alloc::rc::Rc;
use core::convert::Infallible;
use evm::executor::stack::Log;
use evm::gasometer::{GasCost, Gasometer, MemoryCost};
use evm::{
    Capture, Config, Context, CreateScheme, ExitError, ExitFatal, ExitReason, ExitRevert,
    ExitSucceed, Handler, Opcode, Stack, Transfer,
};
use host::runtime::Runtime;
use primitive_types::{H160, H256, U256};
use sha3::{Digest, Keccak256};
use std::cmp::min;
use std::collections::BTreeSet;
use std::fmt::Debug;
use tezos_ethereum::block::BlockConstants;
use tezos_ethereum::withdrawal::Withdrawal;
use tezos_evm_logging::{log, Level::*};

/// Extends ExitReason with our own errors. It avoids using
/// ExitError::Other(<string>) and matching on strings.
#[derive(Debug, Eq, PartialEq)]
pub enum ExtendedExitReason {
    Exit(ExitReason),
    OutOfTicks,
}

impl From<ExitReason> for ExtendedExitReason {
    fn from(e: ExitReason) -> Self {
        Self::Exit(e)
    }
}

/// Outcome of making the [EvmHandler] run an Ethereum transaction
///
/// Be it contract -call, -create or simple transfer, the handler will update the world
/// state in durable storage _and_ produce a summary of the outcome that will be needed
/// for creating a transaction receipt.
#[derive(Debug, Eq, PartialEq)]
pub struct ExecutionOutcome {
    /// How much gas was used for processing an entire transaction.
    pub gas_used: u64,
    /// Whether the transaction succeeded or not.
    ///  - In case of transfer-, whether the funds were transferred
    ///  - In case of call-, whether toplevel call returned or stopped (success), or
    ///    something else (revert, invalid code, etc. are non-successes).
    ///  - In case of create-, whethere a new contract was created or not.
    pub is_success: bool,
    /// The sputnik reason for ending execution. In case of transfers, this is made up
    /// (sputnik Doesn't execute those - we do).
    pub reason: ExtendedExitReason,
    /// In case of create- transactions, this field contains address of the new contract
    pub new_address: Option<H160>,
    /// Logs generated by the transaction.
    pub logs: Vec<Log>,
    /// Result of the execution
    pub result: Option<Vec<u8>>,
    /// Withdrawals generated by the transaction. This field will be empty if the
    /// transaction fails (or if the transaction doesn't produce any withdrawals).
    pub withdrawals: Vec<Withdrawal>,
    /// Number of estimated ticks used at the end of the contract call
    pub estimated_ticks_used: u64,
}

/// The result of calling a contract as expected by the SputnikVM EVM implementation.
/// First part of the tuple tells Sputnik how the execution went (success or failure
/// and in what way). Second part tells Sputnik the return data if any.
type CallOutcome = (ExitReason, Vec<u8>);

// Will be used to check precondition before executing a call or a create
pub enum Precondition {
    PassPrecondition,
    PreconditionErr(ExitReason),
    EthereumErr(EthereumError),
}

/// The result of creating a contract as expected by the SputnikVM EVM implementation.
/// First part of the triple is the execution outcome - same as for normal contract
/// execution. Second part is the address of the newly created contract, if one was
/// created. Last part is the return value, which is required by Sputnik, but it is
/// always an empty vector when this type is used for create outcome.
///
/// Beware that this type is sometimes used as outcome of a _call_. This is simply to
/// be able to use the `end_xxx_transaction` functions for both contract -create and
/// -call. In this case, the last element of the triple can be non-empty, and the
/// address will be `None`.
type CreateOutcome = (ExitReason, Option<H160>, Vec<u8>);

/// Wrap ethereum errors in the SputnikVM errors
///
/// This function wraps critical errors that indicate something is wrong
/// with the kernel or rollup node into errors that can be passed on to
/// SputnikVM execution. This is needed if an error occurs in a callback
/// called by SputnikVM.
fn ethereum_error_to_exit_reason(exit_reason: &EthereumError) -> ExitReason {
    ExitReason::Fatal(ExitFatal::Other(Cow::from(format!("{:?}", exit_reason))))
}

pub enum TransferExitReason {
    Returned,
    OutOfFund,
}

/// Data related to the current transaction layer
struct TransactionLayerData<'config> {
    /// Gasometer for the current transaction layer. If this value is
    /// `None`, then the current transaction has no gas limit and no
    /// gas accounting.
    pub gasometer: Option<Gasometer<'config>>,
    /// Whether the current transaction is static or not, ie, if the
    /// transaction is allowed to update durable storage.
    pub is_static: bool,
    /// The log records gathered in this layer of transactions and any
    /// committed sub layers.
    pub logs: Vec<Log>,
    /// The addresses of contracts that have been deleted as part of
    /// the current transaction.
    pub deleted_contracts: BTreeSet<H160>,
    /// Any withdrawals generated by the current transaction level and
    /// successful sub-levels.
    pub withdrawals: Vec<Withdrawal>,
    /// Keep track of accessed adresses and storages indices.
    /// See EIP-2929 and YP section 6.1
    pub accessed_storage_keys: AccessRecord,
}

impl<'config> TransactionLayerData<'config> {
    /// Create the data associated with one layer of transactions -
    /// one Ethereum transaction context. It initially has no log
    /// records. If the gas limit is `None`, then there will be no
    /// accounting for gas usage throughout the transaction, ie, there
    /// will be no gasometer.
    pub fn new(
        is_static: bool,
        gas_limit: Option<u64>,
        config: &'config Config,
        accessed_storage_keys: AccessRecord,
    ) -> Self {
        TransactionLayerData {
            gasometer: gas_limit.map(|gl| Gasometer::new(gl, config)),
            is_static,
            logs: vec![],
            deleted_contracts: BTreeSet::new(),
            withdrawals: vec![],
            accessed_storage_keys,
        }
    }
}

#[cfg(feature = "benchmark")]
mod benchmarks {

    use super::*;

    /// These values encodes the result of an evaluation step of the virtual
    /// machine. They can be used to filter some data that can be seen as non
    /// conclusive or irrelevant for the ticks model, or simply for data
    /// analysis.
    const STEP_CONTINUE: u8 = 0;
    const SUCCEED_STOP: u8 = 1;
    const SUCCEED_RETURN: u8 = 2;
    const SUCCEED_SUICIDE: u8 = 3;
    const EXIT_ERROR: u8 = 4;
    const EXIT_REVERT: u8 = 5;
    const EXIT_FATAL: u8 = 6;
    const TRAP: u8 = 7;

    #[inline(always)]
    fn step_exit_reason<T>(capture: &Result<(), Capture<ExitReason, T>>) -> u8 {
        match capture {
            Ok(()) => STEP_CONTINUE,
            Err(Capture::Exit(ExitReason::Succeed(ExitSucceed::Stopped))) => SUCCEED_STOP,
            Err(Capture::Exit(ExitReason::Succeed(ExitSucceed::Returned))) => {
                SUCCEED_RETURN
            }
            Err(Capture::Exit(ExitReason::Succeed(ExitSucceed::Suicided))) => {
                SUCCEED_SUICIDE
            }
            Err(Capture::Exit(ExitReason::Error(_))) => EXIT_ERROR,
            Err(Capture::Exit(ExitReason::Revert(_))) => EXIT_REVERT,
            Err(Capture::Exit(ExitReason::Fatal(_))) => EXIT_FATAL,
            Err(Capture::Trap(_)) => TRAP,
        }
    }

    // About the two `static mut` below and their usage
    //
    // Low key optimisation to avoid the formatting: we know that the data are
    // always 1 byte for the opcode, 8 bytes pour the gas (u64), 1 byte for the
    // step exit reason. The messages are preallocated and updated with the
    // correct values each time they are called. It avoid using the formatting.
    // The overhead of formatting is significative.

    // The start section for the opcodes expects a single byte which is the
    // current opcode.
    static mut START_OPCODE_SECTION_MSG: [u8; 35] =
        *b"__wasm_debugger__::start_section(\0)";

    // The start section for the precompiles expects the address of the
    // contract (20 bytes) and the size of the data (4 bytes).
    static mut START_PRECOMPILE_SECTION_MSG: [u8; 58] =
        *b"__wasm_debugger__::start_section(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)";

    #[inline(always)]
    pub fn start_opcode_section<Host: Runtime>(host: &mut Host, opcode: &Opcode) {
        unsafe {
            START_OPCODE_SECTION_MSG[33] = opcode.as_u8();
            host.write_debug(core::str::from_utf8_unchecked(&START_OPCODE_SECTION_MSG));
        }
    }

    #[inline(always)]
    pub fn start_precompile_section<Host: Runtime>(
        host: &mut Host,
        address: H160,
        input: &Vec<u8>,
    ) {
        unsafe {
            START_PRECOMPILE_SECTION_MSG[33..53].copy_from_slice(address.as_bytes());
            START_PRECOMPILE_SECTION_MSG[53..57]
                .copy_from_slice(&input.len().to_be_bytes());
            host.write_debug(core::str::from_utf8_unchecked(
                &START_PRECOMPILE_SECTION_MSG,
            ));
        }
    }

    // The value of the ending sections are:
    // - 8 bytes for the gas, in little endian
    // - 1 byte that describes the continuation of the evaluation: it either
    //   continues to the next opcode (`STEP_CONTINUE`) or stops for a given
    //   reason, this reason being encoded in a byte. These values are described
    //   at the beginning of the `benchmarks` module.
    static mut END_OPCODE_SECTION_MSG: [u8; 41] =
        *b"__wasm_debugger__::end_section(\0\0\0\0\0\0\0\0\0)";

    static mut END_PRECOMPILE_SECTION_MSG: [u8; 32] =
        *b"__wasm_debugger__::end_section()";

    #[inline(always)]
    pub fn end_opcode_section<Host: Runtime, T>(
        host: &mut Host,
        gas: u64,
        step_result: &Result<(), Capture<ExitReason, T>>,
    ) {
        unsafe {
            END_OPCODE_SECTION_MSG[31..39].copy_from_slice(&gas.to_le_bytes());
            END_OPCODE_SECTION_MSG[39] = step_exit_reason(step_result);
            host.write_debug(core::str::from_utf8_unchecked(&END_OPCODE_SECTION_MSG));
        }
    }

    #[inline(always)]
    pub fn end_precompile_section<Host: Runtime>(host: &mut Host) {
        unsafe {
            host.write_debug(core::str::from_utf8_unchecked(&END_PRECOMPILE_SECTION_MSG));
        }
    }
}

pub fn create_address_legacy(caller: &H160, nonce: &U256) -> H160 {
    let mut stream = rlp::RlpStream::new_list(2);
    stream.append(caller);
    stream.append(nonce);
    H256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()
}

/// The implementation of the SputnikVM [Handler] trait
pub struct EvmHandler<'a, Host: Runtime> {
    /// The host
    host: &'a mut Host,
    /// The ethereum accounts storage
    evm_account_storage: &'a mut EthereumAccountStorage,
    /// The original caller initiating the toplevel transaction
    origin: H160,
    /// The constants for the current block
    pub block: &'a BlockConstants,
    /// The precompiled functions
    precompiles: &'a dyn PrecompileSet<Host>,
    /// The configuration, eg, London or Frontier for execution
    config: &'a Config,
    /// The contexts associated with transaction(s) currently in
    /// progress
    transaction_data: Vec<TransactionLayerData<'a>>,
    /// Estimated number of ticks remaining for the current run
    pub ticks_allocated: u64,
    /// Estimated ticks spent for the execution of the current transaction,
    /// according to the ticks per gas per opcode model
    pub estimated_ticks_used: u64,
    /// The effective gas price of the current transaction
    effective_gas_price: U256,
    /// Whether warm/cold storage and address access is enabled
    /// If not, all access are considered warm
    pub enable_warm_cold_access: bool,
}

impl<'a, Host: Runtime> EvmHandler<'a, Host> {
    /// Create a new handler to suit a new, initial EVM call context
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        host: &'a mut Host,
        evm_account_storage: &'a mut EthereumAccountStorage,
        origin: H160,
        block: &'a BlockConstants,
        config: &'a Config,
        precompiles: &'a dyn PrecompileSet<Host>,
        ticks_allocated: u64,
        effective_gas_price: U256,
        enable_warm_cold_access: bool,
    ) -> Self {
        Self {
            host,
            evm_account_storage,
            origin,
            block,
            config,
            precompiles,
            transaction_data: vec![],
            ticks_allocated,
            estimated_ticks_used: 0,
            effective_gas_price,
            enable_warm_cold_access,
        }
    }

    /// Get the total amount of gas used for the duration of the current
    /// transaction.
    pub fn gas_used(&self) -> u64 {
        self.transaction_data
            .last()
            .map(|layer| {
                layer
                    .gasometer
                    .as_ref()
                    .map(|g| g.total_used_gas())
                    .unwrap_or(0_u64)
            })
            .unwrap_or(0_u64)
    }

    /// Get the amount of gas still available for the current transaction.
    fn gas_remaining(&self) -> u64 {
        self.transaction_data
            .last()
            .map(|layer| layer.gasometer.as_ref().map(|g| g.gas()).unwrap_or(0_u64))
            .unwrap_or(0_u64)
    }

    /// Record the cost of a static-cost opcode
    pub fn record_cost(&mut self, cost: u64) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_cost(cost))
            .unwrap_or(Ok(()))
    }

    /// Record code deposit. Pay per byte for a CREATE operation
    pub fn record_deposit(&mut self, len: usize) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_deposit(len))
            .unwrap_or(Ok(()))
    }

    /// Record the cost of a dynamic-cost opcode
    fn record_dynamic_cost(
        &mut self,
        cost: GasCost,
        memory_cost: Option<MemoryCost>,
    ) -> Result<(), ExitError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(ExitError::Other(Cow::from("Recording cost, but there is no transaction in progress")))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_dynamic_cost(cost, memory_cost))
            .unwrap_or(Ok(()))
    }

    /// Record the refund of a contract call. This differs from a storage
    /// operation refund in that the refunded gas can be used again by the
    /// same transaction. Function name reflects the SputnikVM name used to
    /// implement this functionality.
    fn record_stipend(&mut self, stipend: u64) -> Result<(), EthereumError> {
        let Some(layer) = self.transaction_data.last_mut() else {
            return Err(EthereumError::InconsistentTransactionStack(self.transaction_data.len(), false, false))
        };

        layer
            .gasometer
            .as_mut()
            .map(|gasometer| gasometer.record_stipend(stipend))
            .unwrap_or(Ok(()))
            .map_err(|_| {
                EthereumError::InconsistentState(Cow::from(
                    "Recording a stipend returned an error",
                ))
            })
    }

    /// Mark a location in durable storage as _hot_ for the purpose of calculating
    /// cost of SSTORE and SLOAD. Return type chosen for compatibility with the
    /// SputnikVM functions that need to call this function.
    fn mark_storage_as_hot(
        &mut self,
        address: H160,
        index: H256,
    ) -> Result<(), ExitError> {
        if !self.enable_warm_cold_access {
            return Ok(());
        }

        match self.transaction_data.last_mut() {
            Some(layer) => {
                layer.accessed_storage_keys.insert_storage(address, index);
                Ok(())
            }
            None => Err(ExitError::Other(Cow::from(
                "Invalid transaction data stack for mark_storage_as_hot",
            ))),
        }
    }

    /// Mark an address as _hot_ for the purpose of calculating
    /// cost of *CALL, BALANCE, EXT* and SELFDESTRUCT. Return type chosen for compatibility with the
    /// SputnikVM functions that need to call this function.
    fn mark_address_as_hot(&mut self, address: H160) -> Result<(), ExitError> {
        if !self.enable_warm_cold_access {
            return Ok(());
        }

        match self.transaction_data.last_mut() {
            Some(layer) => {
                layer.accessed_storage_keys.insert_address(address);
                Ok(())
            }
            None => Err(ExitError::Other(Cow::from(
                "Invalid transaction data stack for mark_address_as_hot",
            ))),
        }
    }

    /// Check if some location in durable storage is hot
    fn is_storage_hot(&self, address: H160, index: H256) -> Result<bool, ExitError> {
        let Some(layer) = self.transaction_data.last() else {
            return Err(ExitError::Other(Cow::from("Invalid transaction data stack for is_storage_hot")))
        };

        Ok(layer.accessed_storage_keys.contains_storage(address, index))
    }

    /// Check if address is hot
    fn is_address_hot(&self, address: H160) -> Result<bool, ExitError> {
        let Some(layer) = self.transaction_data.last() else {
                return Err(ExitError::Other(Cow::from("Invalid transaction data stack for is_address_hot")))
            };

        Ok(layer.accessed_storage_keys.contains_address(address))
    }

    /// Check if an address has either a nonzero nonce, or a nonzero code length, i.e., if the address exists.
    fn is_colliding(&mut self, address: H160) -> Result<bool, EthereumError> {
        let Some(account) = self.get_account(address) else {
            return Ok(false);
        };

        let has_code = account
            .code_size(self.borrow_host())
            .map(|s| s != U256::zero())?;
        let non_zero_nonce = account
            .nonce(self.borrow_host())
            .map(|s| s != U256::zero())?;

        Ok(has_code || non_zero_nonce)
    }

    /// Returns true if there is a static transaction in progress, otherwise
    /// return false.
    fn is_static(&self) -> bool {
        self.transaction_data
            .last()
            .map(|data| data.is_static)
            .unwrap_or(false)
    }

    /// Record the base fee part of the transaction cost. We need the SputnikVM
    /// error code in case this goes wrong, so that's what we return.
    fn record_base_gas_cost(
        &mut self,
        is_create: bool,
        data: &[u8],
    ) -> Result<(), ExitError> {
        let base_cost = if is_create {
            self.config.gas_transaction_create
        } else {
            self.config.gas_transaction_call
        };

        let data_cost: u64 = data
            .iter()
            .map(|datum| {
                if *datum == 0_u8 {
                    self.config.gas_transaction_zero_data
                } else {
                    self.config.gas_transaction_non_zero_data
                }
            })
            .sum();

        self.record_cost(base_cost + data_cost)
    }

    /// Add withdrawals to the current transaction layer
    fn add_withdrawals(
        &mut self,
        withdrawals: &mut Vec<Withdrawal>,
    ) -> Result<(), EthereumError> {
        match self.transaction_data.last_mut() {
            Some(layer) => {
                layer.withdrawals.try_reserve_exact(withdrawals.len())?;
                layer.withdrawals.append(withdrawals);

                Ok(())
            }
            None => Err(EthereumError::InconsistentTransactionStack(0, false, false)),
        }
    }

    /// Have the caller account pay for gas. Returns `Ok(true)` if the payment
    /// went through; returns `Ok(false)` if `caller` doesn't have the funds.
    /// Return `Err(...)` in case something is at fault with durable storage or
    /// runtime.
    pub fn pre_pay_transactions(
        &mut self,
        caller: H160,
        gas_limit: Option<u64>,
        effective_gas_price: U256,
    ) -> Result<bool, EthereumError> {
        let Some(gas_limit) = gas_limit else { return Ok(true) };

        let amount = U256::from(gas_limit)
            .checked_mul(effective_gas_price)
            .ok_or(EthereumError::GasPaymentOverflow)?;

        log!(
            self.host,
            Debug,
            "{caller:?} pays {amount:?} for transaction"
        );

        self.get_or_create_account(caller)?
            .balance_remove(self.host, amount)
            .map_err(EthereumError::from)
    }

    /// Repay unused gas
    pub fn repay_gas(
        &mut self,
        caller: H160,
        unused_gas: Option<u64>,
        effective_gas_price: U256,
    ) -> Result<(), EthereumError> {
        let Some(unused_gas) = unused_gas else { return Ok(()) };

        let amount = U256::from(unused_gas)
            .checked_mul(effective_gas_price)
            .ok_or(EthereumError::GasPaymentOverflow)?;

        log!(
            self.host,
            Debug,
            "{caller:?} refunded {amount:?} for transaction"
        );

        self.get_or_create_account(caller)?
            .balance_add(self.host, amount)
            .map_err(EthereumError::from)
    }

    /// Account for the estimated ticks spent during the execution of the given opcode
    pub fn account_for_ticks(
        &mut self,
        opcode: &Opcode,
        gas: u64,
    ) -> Result<(), EthereumError> {
        self.estimated_ticks_used += tick_model_opcodes::ticks(opcode, gas);
        if self.estimated_ticks_used > self.ticks_allocated {
            Err(EthereumError::OutOfTicks)
        } else {
            Ok(())
        }
    }

    /// Execute a SputnikVM run with this handler
    ///
    /// Never inlined when the kernel is compiled for benchmarks, to ensure the
    /// function is visible in the profiling results.
    #[cfg_attr(feature = "benchmark", inline(never))]
    fn execute(
        &mut self,
        runtime: &mut evm::Runtime,
    ) -> Result<ExitReason, EthereumError> {
        loop {
            // This decomposition allows both benchmarking the ticks per gas
            // consumption of opcode and implement the tick model at the opcode
            // level. At the end of each step if the kernel takes more than the
            // allocated ticks the transaction is marked as failed.
            let opcode = runtime.machine().inspect().map(|p| p.0);

            #[cfg(feature = "benchmark")]
            if let Some(opcode) = opcode {
                benchmarks::start_opcode_section(self.host, &opcode);
            }

            // For now, these variables capturing the gas one will be marked
            // unused without benchmarking, but they will be used during the
            // tick accounting.
            #[cfg_attr(not(feature = "benchmark"), allow(unused_variables))]
            let gas_before = self.gas_used();

            let step_result = runtime.step(self);

            #[cfg_attr(not(feature = "benchmark"), allow(unused_variables))]
            let gas_after = self.gas_used();

            if let Some(opcode) = opcode {
                let gas = gas_after - gas_before;
                self.account_for_ticks(&opcode, gas)?;
                #[cfg(feature = "benchmark")]
                benchmarks::end_opcode_section(self.host, gas, &step_result);
            };

            match step_result {
                Ok(()) => (),
                Err(Capture::Exit(reason)) => return Ok(reason),
                Err(Capture::Trap(_)) => return Err(EthereumError::InternalTrapError),
            }
        }
    }

    fn create_address(&mut self, scheme: CreateScheme) -> H160 {
        match scheme {
            CreateScheme::Create2 {
                caller,
                code_hash,
                salt,
            } => {
                let mut hasher = Keccak256::new();
                hasher.update([0xff]);
                hasher.update(caller);
                hasher.update(salt);
                hasher.update(code_hash);
                H256::from_slice(hasher.finalize().as_slice()).into()
            }
            CreateScheme::Legacy { caller } => {
                let nonce = self.get_nonce(caller);
                create_address_legacy(&caller, &nonce)
            }
            CreateScheme::Fixed(address) => address,
        }
    }

    /// Execute a transfer between two accounts
    ///
    /// In case the transfer succeeds, the function returns
    /// `Ok(ExitReason::Succeed(ExitSucceed::Returned))`. In case the
    /// transaction fails, but execution doesn't encounter non-contract or
    /// -account errors, it returns `Ok(ExitReason::Error(err))`, where `err`
    /// indicates what went wrong (insufficient balance, etc.). In case of
    /// critical errors in the rollup node or kernel, an `Err(err)` is returned,
    /// where `err` indicates what went wrong, eg, a storage error.
    fn execute_transfer(
        &mut self,
        from: H160,
        to: H160,
        value: U256,
    ) -> Result<TransferExitReason, EthereumError> {
        log!(
            self.host,
            Debug,
            "Executing a transfer from {} to {} of {}",
            from,
            to,
            value
        );

        if value == U256::zero() {
            // Nothing to transfer so succeeds by default
            Ok(TransferExitReason::Returned)
        } else if let Some(mut from_account) = self.get_account(from) {
            let mut to_account = self.get_or_create_account(to)?;

            if from_account.balance_remove(self.host, value)? {
                to_account
                    .balance_add(self.host, value)
                    .map_err(EthereumError::from)?;
                Ok(TransferExitReason::Returned)
            } else {
                log!(
                    self.host,
                    Debug,
                    "Failed transfer due to insufficient funds, value: {:?}, from: {:?}, to: {:?}",
                    value,
                    from_account,
                    to
                );

                Ok(TransferExitReason::OutOfFund)
            }
        } else {
            log!(self.host, Debug, "'from' account {:?} is empty", from);
            // Accounts of zero balance by default, so this must be
            // an underflow.
            Ok(TransferExitReason::OutOfFund)
        }
    }

    // Stack depth is the number of internal call that happened in the EVM
    // It's just the number of transaction minus the initial one
    // NB: Different from `stack_depth` in `src/kernel_sdk/storage/src/storage.rs`
    fn stack_depth(&self) -> usize {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();
        number_of_tx_layer.checked_sub(1).unwrap_or_default()
    }

    fn has_enough_fund(&self, from: H160, value: &U256) -> Result<bool, EthereumError> {
        if value.is_zero() {
            Ok(true)
        } else if let Some(from_account) = self.get_account(from) {
            let balance = from_account
                .balance(self.host)
                .map_err(EthereumError::from)?;
            let enough_balance = &balance >= value;
            if !enough_balance {
                log!(
                    self.host,
                    Debug,
                    "Insufficient funds, balance of {:?} is {:?} but needs at least {:?}",
                    from,
                    balance,
                    value
                );
            }
            Ok(enough_balance)
        } else {
            log!(self.host, Debug, "'from' account {:?} is empty", from);
            // Accounts of zero balance by default, so this must be
            // an underflow.
            Ok(false)
        }
    }

    fn end_create(
        &mut self,
        runtime: evm::Runtime,
        creation_result: Result<ExitReason, EthereumError>,
        address: H160,
    ) -> Result<CreateOutcome, EthereumError> {
        match creation_result {
            Ok(sub_context_result @ ExitReason::Succeed(ExitSucceed::Suicided)) => {
                Ok((sub_context_result, Some(address), vec![]))
            }
            Ok(sub_context_result @ ExitReason::Succeed(_)) => {
                let code_out = runtime.machine().return_value();

                if code_out.first() == Some(&0xef) {
                    // EIP-3541: see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3541.md
                    return Ok((
                        ExitReason::Error(ExitError::InvalidCode(Opcode(0xef))),
                        None,
                        vec![],
                    ));
                }

                // We check that the maximum allowed code size as specified by EIP-170 can not
                // be reached.
                if let Some(create_contract_limit) = self.config.create_contract_limit {
                    if code_out.len() > create_contract_limit {
                        // EIP-170: see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-170.md
                        return Ok((
                            ExitReason::Error(ExitError::CreateContractLimit),
                            None,
                            vec![],
                        ));
                    }
                }

                if let Err(err) = self.record_deposit(code_out.len()) {
                    return Ok((ExitReason::Error(err), None, vec![]));
                }

                self.set_contract_code(address, code_out)?;

                Ok((sub_context_result, Some(address), vec![]))
            }
            Ok(sub_context_result @ ExitReason::Revert(_)) => {
                // EIP-140: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md
                // In case of a REVERT in a context of a CREATE, CREATE2, the error message
                // is available in the returndata buffer
                Ok((sub_context_result, None, runtime.machine().return_value()))
            }
            // Since the creation fails, return address 0 (`None` in our case) (https://www.evm.codes/#f0?fork=shanghai)
            Ok(create_err @ ExitReason::Error(_)) => Ok((create_err, None, vec![])),
            Ok(create_err @ ExitReason::Fatal(_)) => Ok((create_err, None, vec![])),
            Err(err) => Err(err),
        }
    }

    // Sub function to determine if the `caller` can create a new internal transaction.
    // According to the Ethereum yellow paper (p.37) for `CALL`, `CREATE`, ... instructions that
    // creates a new substate, it must always check that there are no `OutOfFund` or `CallTooDeep`
    fn can_begin_inter_transaction(&self, caller: H160, value: &U256) -> Precondition {
        // This check SHOULD be called outside of `begin_inter` and `end_inter`, this way
        // we can reproduce the exact same check on the stack from the Ethereum yellow paper (p.37).
        match (
            self.has_enough_fund(caller, value),
            self.stack_depth() < self.config.stack_limit,
        ) {
            (Ok(true), true) => Precondition::PassPrecondition,
            (Ok(false), _) => {
                Precondition::PreconditionErr(ExitReason::Error(ExitError::OutOfFund))
            }
            (Ok(_), false) => {
                Precondition::PreconditionErr(ExitReason::Error(ExitError::CallTooDeep))
            }
            (Err(err), _) => Precondition::EthereumErr(err),
        }
    }

    // Sub function to handle the collision part, we pinpoint two ways of colliding:
    //   - the contract already exists
    //   - it's been marked as `deleted` within the same transaction
    fn contract_will_collide(&mut self, address: H160) -> Precondition {
        if self.deleted(address) {
            // The contract has been deleted, so the address is empty.
            // We are trying to re-create the same contract that was deleted at
            // the same transaction level: this is not allowed.
            // TODO/NB: https://gitlab.com/tezos/tezos/-/issues/6783
            // This behaviour is appropriate to <=Shanghai configuration.
            // In the upcoming Cancun fork, the semantic of this behaviour will change.
            Precondition::PreconditionErr(ExitReason::Error(ExitError::CreateCollision))
        } else {
            // TODO: https://gitlab.com/tezos/tezos/-/issues/6716
            // Create collision and failed transfers should use up all the gas
            match self.is_colliding(address) {
                Ok(false) => Precondition::PassPrecondition,
                Ok(true) => {
                    log!(
                        self.host,
                        Debug,
                        "Failed to create contract at {:?}. Address is non-empty",
                        address
                    );
                    Precondition::PreconditionErr(ExitReason::Error(
                        ExitError::CreateCollision,
                    ))
                }
                Err(collide_err) => Precondition::EthereumErr(collide_err),
            }
        }
    }

    /// Create a contract
    ///
    /// Performs the actual contract creation for both transactions initiated
    /// by external accounts and contract creation initiated through contract
    /// execution.
    ///
    /// In the specific case where this function is called via the CREATE opcode,
    /// it needs to bump the nonce. If it's a transaction initated by external
    /// accounts, the nonce must be bumped by the caller.
    fn execute_create(
        &mut self,
        caller: H160,
        value: U256,
        initial_code: Vec<u8>,
        address: H160,
    ) -> Result<CreateOutcome, EthereumError> {
        log!(self.host, Debug, "Executing a contract create");

        // We check that the maximum allowed init code size as specified by EIP-3860
        // can not be reached.
        if let Some(max_initcode_size) = self.config.max_initcode_size {
            if initial_code.len() > max_initcode_size {
                return Ok((
                    ExitReason::Error(ExitError::CreateContractLimit),
                    None,
                    vec![],
                ));
            }
        }

        // Charge of 2 gas for every 32-byte chunk of initcode to represent
        // the cost of jumpdest-analysis.
        // See: https://eips.ethereum.org/EIPS/eip-3860
        // * We target wasm32-unknown-unknown, so this conversion should be safe.
        // * The division behave as an unsafe div_floor which we can't use since
        //   it's nightly-only.
        // * The `unwrap_or` is there in case there's an unexpected behaviour
        //   that we missed.
        let extra_cost: u64 = (initial_code.len() / 32).try_into().unwrap_or(0) * 2;

        if self.record_cost(extra_cost).is_err() {
            log!(
                self.host,
                Debug,
                "Not enought gas for call. Required at least: {:?} for the init code size extra cost.",
                extra_cost
            );

            return Ok((ExitReason::Error(ExitError::OutOfGas), None, vec![]));
        }

        let context = Context {
            address,
            caller,
            apparent_value: value,
        };

        let mut runtime = evm::Runtime::new(
            Rc::new(initial_code),
            Rc::new(Vec::new()),
            context,
            self.config.stack_limit,
            self.config.memory_limit,
        );

        // Execute if there is no collision
        let creation_result = match self.contract_will_collide(address) {
            Precondition::PassPrecondition => {
                match self.execute_transfer(caller, address, value) {
                    Ok(TransferExitReason::Returned) => {
                        match self.increment_nonce(address) {
                            Ok(()) => self.execute(&mut runtime),
                            Err(eth_err) => Err(eth_err),
                        }
                    }
                    Ok(TransferExitReason::OutOfFund) => {
                        Ok(ExitReason::Error(ExitError::OutOfFund))
                    }
                    Err(err) => Err(err),
                }
            }
            Precondition::PreconditionErr(collision) => Ok(collision),
            Precondition::EthereumErr(err) => Err(err),
        };

        self.end_create(runtime, creation_result, address)
    }

    /// Call a contract
    ///
    /// Perform the actual contract execution - works both for executing an
    /// Ethereum transaction as initiated by an external account or as aresult
    /// of any of the -CALL instructions.
    ///
    /// The outcome is encoded as a SputnikVM _Create_ outcome for easy transaction
    /// handling. The new address "field" in the triple is always `None`.
    #[allow(clippy::too_many_arguments)]
    fn execute_call(
        &mut self,
        address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        transaction_context: TransactionContext,
    ) -> Result<CreateOutcome, EthereumError> {
        let stack_depth = self.stack_depth();
        log!(
            self.host,
            Debug,
            "Executing contract call on contract {} at depth: {}",
            address,
            stack_depth
        );

        // TODO: check gas
        // issue: https://gitlab.com/tezos/tezos/-/issues/5120

        // TODO: add transfer to gas (if it is there)
        // issue: https://gitlab.com/tezos/tezos/-/issues/5121

        if let Some(ref transfer) = transfer {
            match self.execute_transfer(
                transaction_context.context.caller,
                transaction_context.context.address,
                transfer.value,
            )? {
                TransferExitReason::OutOfFund => {
                    return Ok((ExitReason::Error(ExitError::OutOfFund), None, vec![]))
                }
                TransferExitReason::Returned => (), // Otherwise result is ok and we do nothing and continue
            }
        }
        #[cfg(feature = "benchmark")]
        benchmarks::start_precompile_section(self.host, address, &input);

        let precompile_execution_result = self.precompiles.execute(
            self,
            address,
            &input,
            &transaction_context.context,
            self.is_static(),
            transfer,
        );

        #[cfg(feature = "benchmark")]
        benchmarks::end_precompile_section(self.host);

        if let Some(precompile_result) = precompile_execution_result {
            match precompile_result {
                Ok(mut outcome) => {
                    self.add_withdrawals(&mut outcome.withdrawals)?;
                    self.estimated_ticks_used += outcome.estimated_ticks;
                    Ok((outcome.exit_status, None, outcome.output))
                }
                Err(err) => Err(err),
            }
        } else {
            let code = self.code(address);

            let mut runtime = evm::Runtime::new(
                Rc::new(code),
                Rc::new(input),
                transaction_context.context,
                self.config.stack_limit,
                self.config.memory_limit,
            );

            let result = self.execute(&mut runtime);

            return Ok((result?, None, runtime.machine().return_value()));
        }
    }

    /// Perform a contract call transaction
    pub fn call_contract(
        &mut self,
        caller: H160,
        callee: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
        is_static: bool,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(is_static, gas_limit)?;

        if self.mark_address_as_hot(caller).is_err() {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark caller address as hot",
            )));
        }

        if self.mark_address_as_hot(callee).is_err() {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark callee address as hot",
            )));
        }

        if let Err(err) = self.record_base_gas_cost(false, &input) {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let result = self.execute_call(
            callee,
            value.map(|value| Transfer {
                source: caller,
                target: callee,
                value,
            }),
            input,
            TransactionContext::new(caller, callee, value.unwrap_or(U256::zero())),
        );

        self.end_initial_transaction(result)
    }

    /// Perform a create-contract transaction
    pub fn create_contract(
        &mut self,
        caller: H160,
        value: Option<U256>,
        input: Vec<u8>,
        gas_limit: Option<u64>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        self.begin_initial_transaction(false, gas_limit)?;

        if self.mark_address_as_hot(caller).is_err() {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark caller address as hot",
            )));
        }

        if let Err(err) = self.record_base_gas_cost(true, &input) {
            return self.end_initial_transaction(Ok((
                ExitReason::Error(err),
                None,
                vec![],
            )));
        }

        let default_create_scheme = CreateScheme::Legacy { caller };

        let address = self.create_address(default_create_scheme);

        if self.mark_address_as_hot(address).is_err() {
            return Err(EthereumError::InconsistentState(Cow::from(
                "Failed to mark callee address as hot",
            )));
        }

        let result =
            self.execute_create(caller, value.unwrap_or_default(), input, address);

        self.end_initial_transaction(result)
    }

    fn get_or_create_account(
        &self,
        address: H160,
    ) -> Result<EthereumAccount, EthereumError> {
        self.evm_account_storage
            .get_or_create(
                self.host,
                &account_path(&address).map_err(AccountStorageError::from)?,
            )
            .map_err(EthereumError::from)
    }

    fn get_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note: if we get an error we cannot report this to SputnikVM as the return types
        // for functions that use _this_ function don't support errors. Rather than do
        // error handling in all those functions (and those we'll write in the future), we
        // do the error handling here.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get(self.host, &path)
                .ok()
                .flatten()
        } else {
            log!(
                self.host,
                Debug,
                "Failed to get account path for EVM handler get_account"
            );
            None
        }
    }

    fn get_original_account(&self, address: H160) -> Option<EthereumAccount> {
        // Note, there is no way to recover from an error when creating the
        // account path. At this point we are being called from SputnikVM and
        // it does not allow for this to fail, so we just return None.
        if let Ok(path) = account_path(&address) {
            self.evm_account_storage
                .get_original(self.host, &path)
                .ok()
                .flatten()
        } else {
            log!(
                self.host,
                Debug,
                "Failed to get account path for EVM handler get_original_account"
            );
            None
        }
    }

    pub fn increment_nonce(&mut self, address: H160) -> Result<(), EthereumError> {
        match account_path(&address) {
            Ok(path) => {
                let mut account =
                    self.evm_account_storage.get_or_create(self.host, &path)?;
                account
                    .increment_nonce(self.host)
                    .map_err(EthereumError::from)
            }
            Err(err) => {
                log!(
                    self.host,
                    Debug,
                    "Failed to increment nonce for account {:?}",
                    address
                );
                Err(EthereumError::from(AccountStorageError::from(err)))
            }
        }
    }

    fn set_contract_code(
        &mut self,
        address: H160,
        code: Vec<u8>,
    ) -> Result<(), EthereumError> {
        self.get_or_create_account(address)?
            .set_code(self.host, &code)
            .map_err(EthereumError::from)
    }

    fn get_nonce(&self, address: H160) -> U256 {
        self.get_account(address)
            .map(|account| account.nonce(self.host).unwrap_or_default())
            .unwrap_or_default()
    }

    /// Completely delete an account including nonce, code, and data. This is for
    /// contract selfdestruct completion, ie, when contract selfdestructs takes final
    /// effect.
    fn delete_contract(&mut self, address: H160) -> Result<(), EthereumError> {
        log!(self.host, Debug, "Deleting contract at {:?}", address);

        self.evm_account_storage
            .delete(
                self.host,
                &account_path(&address).map_err(AccountStorageError::from)?,
            )
            .map_err(EthereumError::from)
    }

    /// Borrow a reference to the host - needed for eg precompiled contracts
    pub fn borrow_host(&mut self) -> &'_ mut Host {
        self.host
    }

    /// Begin the first transaction layer
    ///
    /// This requires that no other transaction is in progress. If there is a
    /// transaction in progress, then the function returns an error to report
    /// this.
    fn begin_initial_transaction(
        &mut self,
        is_static: bool,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();
        log!(self.host, Debug, "Begin initial transaction");

        if number_of_tx_layer > 0 {
            log!(
                self.host,
                Debug,
                "Initial transaction when there is already {} transaction",
                number_of_tx_layer
            );

            return Err(EthereumError::InconsistentTransactionStack(
                number_of_tx_layer,
                true,
                true,
            ));
        }

        self.transaction_data.push(TransactionLayerData::new(
            self.is_static() || is_static,
            gas_limit,
            self.config,
            AccessRecord::new(),
        ));

        self.evm_account_storage
            .begin_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// Final commit of initial transaction
    ///
    /// This requires that only one transaction is in progress. Since we should
    /// never end in a state with a transaction in progress after we are done
    /// executing, such state is the sort of thing that may cause panic.
    fn commit_initial_transaction(
        &mut self,
        new_address: Option<H160>,
        result: Vec<u8>,
        reason: ExitReason,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();
        log!(self.host, Debug, "Committing initial transaction");

        if number_of_tx_layer != 1 {
            log!(
                self.host,
                Debug,
                "Committing initial transaction, but there are {:?} transactions",
                number_of_tx_layer
            );

            return Err(EthereumError::InconsistentTransactionStack(
                number_of_tx_layer,
                true,
                false,
            ));
        }

        if number_of_tx_layer != self.transaction_data.len() {
            return Err(EthereumError::InconsistentTransactionData(
                number_of_tx_layer,
                self.transaction_data.len(),
            ));
        }

        let gas_used = self.gas_used();

        if let Some(last_layer) = self.transaction_data.pop() {
            for address in last_layer.deleted_contracts.iter() {
                if self.delete_contract(*address).is_err() {
                    log!(
                        self.host,
                        Debug,
                        "Failed to remove deleted address {:?}",
                        address
                    );
                }
            }

            self.evm_account_storage
                .commit_transaction(self.host)
                .map_err(EthereumError::from)?;

            Ok(ExecutionOutcome {
                gas_used,
                is_success: true,
                reason: reason.into(),
                new_address,
                logs: last_layer.logs,
                result: Some(result),
                withdrawals: last_layer.withdrawals,
                estimated_ticks_used: self.estimated_ticks_used,
            })
        } else {
            Err(EthereumError::InconsistentState(Cow::from(
                "The transaction data stack is empty when committing the initial transaction",
            )))
        }
    }

    /// Rollback of initial transaction
    ///
    /// This requires that only one transaction is in progress. Since we should
    /// never end in a state with a transaction in progress after we are done
    /// executing, such state is the sort of thing that may cause panic.
    fn rollback_initial_transaction(
        &mut self,
        result: Option<Vec<u8>>,
        reason: ExtendedExitReason,
    ) -> Result<ExecutionOutcome, EthereumError> {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();
        log!(self.host, Debug, "Rolling back the initial transaction");

        if number_of_tx_layer != 1 {
            log!(
                self.host,
                Debug,
                "Rolling back initial transaction, but there are {:?} in progress",
                number_of_tx_layer
            );

            return Err(EthereumError::InconsistentTransactionStack(
                number_of_tx_layer,
                true,
                false,
            ));
        }

        if number_of_tx_layer != self.transaction_data.len() {
            return Err(EthereumError::InconsistentTransactionData(
                number_of_tx_layer,
                self.transaction_data.len(),
            ));
        }

        let gas_used = self.gas_used();

        self.evm_account_storage
            .rollback_transaction(self.host)
            .map_err(EthereumError::from)?;

        let _ = self.transaction_data.pop();

        Ok(ExecutionOutcome {
            gas_used,
            is_success: false,
            reason,
            new_address: None,
            logs: vec![],
            result,
            withdrawals: vec![],
            estimated_ticks_used: self.estimated_ticks_used,
        })
    }

    /// End the initial transaction with either a commit or a rollback. The
    /// outcome depends on the execution result given.
    fn end_initial_transaction(
        &mut self,
        execution_result: Result<CreateOutcome, EthereumError>,
    ) -> Result<ExecutionOutcome, EthereumError> {
        match execution_result {
            Ok((ExitReason::Succeed(r), new_address, result)) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with success: {:?}",
                    r
                );

                self.commit_initial_transaction(
                    new_address,
                    result,
                    ExitReason::Succeed(r),
                )
            }
            Ok((ExitReason::Revert(ExitRevert::Reverted), _, result)) => self
                .rollback_initial_transaction(
                    Some(result),
                    ExitReason::Revert(ExitRevert::Reverted).into(),
                ),
            Ok((ExitReason::Error(error), _, _)) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with an error: {:?}",
                    error
                );

                self.rollback_initial_transaction(None, ExitReason::Error(error).into())
            }
            Ok((ExitReason::Fatal(ExitFatal::Other(cow_str)), _, _)) => {
                self.rollback_initial_transaction(
                    None,
                    ExitReason::Fatal(ExitFatal::Other(cow_str.clone())).into(),
                )?;
                Err(EthereumError::WrappedError(cow_str))
            }
            Ok((ExitReason::Fatal(fatal_error), _, _)) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with a fatal error: {:?}",
                    fatal_error
                );

                self.rollback_initial_transaction(
                    None,
                    ExitReason::Fatal(fatal_error).into(),
                )
            }
            Err(EthereumError::OutOfTicks) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction exhausted the allocated ticks."
                );

                self.rollback_initial_transaction(None, ExtendedExitReason::OutOfTicks)
            }
            Err(err) => {
                log!(
                    self.host,
                    Debug,
                    "The initial transaction ended with an Ethereum error: {:?}",
                    err
                );

                self.rollback_initial_transaction(
                    None,
                    ethereum_error_to_exit_reason(&err).into(),
                )?;
                Err(err)
            }
        }
    }

    /// Begin an intermediate transaction
    fn begin_inter_transaction(
        &mut self,
        is_static: bool,
        gas_limit: Option<u64>,
    ) -> Result<(), EthereumError> {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();
        log!(
            self.host,
            Debug,
            "Begin transaction from {} at transaction depth: {}",
            self.origin(),
            self.stack_depth()
        );

        if number_of_tx_layer == 0 {
            return Err(EthereumError::InconsistentTransactionStack(0, false, true));
        }

        let Some(current_top) = self.transaction_data.last() else {
            return Err(EthereumError::InconsistentTransactionStack(0, false, true));
        };

        let accessed_storage_keys = current_top.accessed_storage_keys.clone();

        self.transaction_data.push(TransactionLayerData::new(
            self.is_static() || is_static,
            gas_limit,
            self.config,
            accessed_storage_keys,
        ));

        self.evm_account_storage
            .begin_transaction(self.host)
            .map_err(EthereumError::from)
    }

    /// Commit an intermediate transaction
    fn commit_inter_transaction(&mut self) -> Result<(), EthereumError> {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();

        if number_of_tx_layer < 2 {
            return Err(EthereumError::InconsistentTransactionStack(
                number_of_tx_layer,
                false,
                false,
            ));
        }

        log!(
            self.host,
            Debug,
            "Commit transaction at transaction depth: {}",
            self.stack_depth()
        );

        let gas_remaining = self.gas_remaining();

        self.evm_account_storage
            .commit_transaction(self.host)
            .map_err(EthereumError::from)?;

        if let Some(mut committed_data) = self.transaction_data.pop() {
            if let Some(top_layer) = self.transaction_data.last_mut() {
                top_layer
                    .logs
                    .try_reserve_exact(committed_data.logs.len())?;
                top_layer.logs.append(&mut committed_data.logs);

                top_layer
                    .withdrawals
                    .try_reserve_exact(committed_data.withdrawals.len())?;
                top_layer
                    .withdrawals
                    .append(&mut committed_data.withdrawals);

                top_layer
                    .deleted_contracts
                    .extend(committed_data.deleted_contracts);
                top_layer.accessed_storage_keys = committed_data.accessed_storage_keys;

                self.record_stipend(gas_remaining)?;

                Ok(())
            } else {
                Err(EthereumError::InconsistentState(Cow::from(
                    "The transaction data stack is empty",
                )))
            }
        } else {
            Err(EthereumError::InconsistentState(Cow::from(
                "The transaction data stack is empty at commit",
            )))
        }
    }

    /// Rollback an intermediate transaction
    fn rollback_inter_transaction(
        &mut self,
        refund_gas: bool,
    ) -> Result<(), EthereumError> {
        let number_of_tx_layer = self.evm_account_storage.stack_depth();

        if number_of_tx_layer < 2 {
            return Err(EthereumError::InconsistentTransactionStack(
                number_of_tx_layer,
                false,
                false,
            ));
        }

        log!(
            self.host,
            Debug,
            "Rollback transaction at transaction depth: {}",
            self.stack_depth()
        );

        if refund_gas {
            let gas_remaining = self.gas_remaining();
            let _ = self.transaction_data.pop();
            self.record_stipend(gas_remaining)?;
        } else {
            let _ = self.transaction_data.pop();
        }

        self.evm_account_storage
            .rollback_transaction(self.host)
            .map_err(EthereumError::from)
    }

    fn rollback_inter_transaction_side_effect<T>(
        handler: &mut EvmHandler<'_, Host>,
        execution_result: CreateOutcome,
        refund_gas: bool,
    ) -> Capture<CreateOutcome, T> {
        if let Err(err) = handler.rollback_inter_transaction(refund_gas) {
            log!(
                handler.host,
                Debug,
                "Rolling back reverted transaction caused an error: {:?}",
                err
            );

            Capture::Exit((ethereum_error_to_exit_reason(&err), None, vec![]))
        } else {
            Capture::Exit(execution_result)
        }
    }

    /// End a transaction based on an execution result from a call to
    /// [execute]. This can be either a rollback or a commit depending
    /// on whether the execution was successful or not.
    ///
    /// This function applies _only_ to intermediate transactions. Calling
    /// it with only the initial transaction in progress is an error.
    fn end_inter_transaction<T>(
        &mut self,
        execution_result: Result<CreateOutcome, EthereumError>,
    ) -> Capture<CreateOutcome, T> {
        match execution_result {
            Ok((ref exit_reason, _, _)) => match exit_reason {
                ExitReason::Succeed(_) => {
                    log!(
                        self.host,
                        Debug,
                        "Intermediate transaction ended with: {:?}",
                        exit_reason
                    );

                    if let Err(err) = self.commit_inter_transaction() {
                        log!(
                            self.host,
                            Debug,
                            "Committing intermediate transaction caused an error: {:?}",
                            err
                        );

                        Capture::Exit((ethereum_error_to_exit_reason(&err), None, vec![]))
                    } else {
                        Capture::Exit(execution_result.unwrap()) // safe unwrap
                    }
                }
                ExitReason::Revert(_) => {
                    log!(
                        self.host,
                        Debug,
                        "Intermediate transaction reverted with: {:?}",
                        exit_reason
                    );

                    Self::rollback_inter_transaction_side_effect(
                        self,
                        execution_result.unwrap(), // safe unwrap
                        true,
                    )
                }
                ExitReason::Error(_) => {
                    log!(
                        self.host,
                        Debug,
                        "Intermediate transaction produced the following error: {:?}",
                        exit_reason
                    );

                    Self::rollback_inter_transaction_side_effect(
                        self,
                        execution_result.unwrap(), // safe unwrap
                        false,
                    )
                }
                ExitReason::Fatal(ExitFatal::CallErrorAsFatal(
                    ExitError::CreateContractLimit,
                )) => {
                    // For more context for why we need this specific case and behaviour
                    // look out for [MAX_INIT_CODE_SIZE_RETURN_HACK] in this file.

                    let create_contract_limit =
                        ExitReason::Error(ExitError::CreateContractLimit);
                    let execution_result = execution_result.unwrap(); // safe unwrap

                    log!(
                        self.host,
                        Debug,
                        "Intermediate transaction produced the following error: {:?}",
                        create_contract_limit
                    );

                    Self::rollback_inter_transaction_side_effect(
                        self,
                        (
                            create_contract_limit,
                            execution_result.1,
                            execution_result.2,
                        ),
                        false,
                    )
                }
                ExitReason::Fatal(_) => {
                    log!(
                        self.host,
                        Debug,
                        "Intermediate transaction produced the following fatal error: {:?}",
                        exit_reason
                    );

                    Self::rollback_inter_transaction_side_effect(
                        self,
                        execution_result.unwrap(), // safe unwrap
                        false,
                    )
                }
            },
            Err(EthereumError::PrecompileFailed(failure_reason)) => {
                // We need this case, otherwise the failure will be considered as fatal
                // when it shouldn't.

                log!(
                    self.host,
                    Debug,
                    "Intermediate precompiled call ended with failure: {:?}",
                    failure_reason
                );

                if let Err(err) = self.rollback_inter_transaction(false) {
                    log!(
                        self.host,
                        Debug,
                        "Rolling back reverted transaction caused an error: {:?}",
                        err
                    );
                }

                Capture::Exit((
                    ExitReason::Error(ExitError::Other(Cow::Owned(format!(
                        "{:?}",
                        EthereumError::PrecompileFailed(failure_reason)
                    )))),
                    None,
                    vec![],
                ))
            }
            Err(err) => {
                log!(
                    self.host,
                    Debug,
                    "Intermediate transaction ended in error: {:?}",
                    err
                );

                if let Err(err) = self.rollback_inter_transaction(false) {
                    log!(
                        self.host,
                        Debug,
                        "Rolling back reverted transaction caused an error: {:?}",
                        err
                    );
                }

                Capture::Exit((ethereum_error_to_exit_reason(&err), None, vec![]))
            }
        }
    }

    fn nested_call_gas_limit(&mut self, target_gas: Option<u64>) -> Option<u64> {
        // Part of EIP-150: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md
        let gas_remaining = self.gas_remaining();
        let max_gas_limit = if self.config.call_l64_after_gas {
            gas_remaining - gas_remaining / 64
        } else {
            gas_remaining
        };
        if let Some(gas) = target_gas {
            Some(min(gas, max_gas_limit))
        } else {
            Some(max_gas_limit)
        }
    }
}

#[allow(unused_variables)]
impl<'a, Host: Runtime> Handler for EvmHandler<'a, Host> {
    type CreateInterrupt = Infallible;
    type CreateFeedback = Infallible;
    type CallInterrupt = Infallible;
    type CallFeedback = Infallible;

    fn balance(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.balance(self.host).ok())
            .unwrap_or(U256::zero())
    }

    fn code_size(&self, address: H160) -> U256 {
        self.get_account(address)
            .and_then(|a| a.code_size(self.host).ok())
            .unwrap_or(U256::zero())
    }

    // Hash of the chosen account's code, the empty hash (CODE_HASH_DEFAULT) if the account has no code,
    // or 0 if the account does not exist or has been destroyed.
    fn code_hash(&self, address: H160) -> H256 {
        if !self.exists(address) {
            return H256::zero();
        }

        self.get_account(address)
            .and_then(|a| a.code_hash(self.host).ok())
            .unwrap_or(CODE_HASH_DEFAULT)
    }

    fn code(&self, address: H160) -> Vec<u8> {
        // TODO: mark address as hot
        // issue: https://gitlab.com/tezos/tezos/-/issues/4866

        self.get_account(address)
            .and_then(|a| a.code(self.host).ok())
            .unwrap_or_default()
    }

    fn storage(&self, address: H160, index: H256) -> H256 {
        self.get_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn original_storage(&self, address: H160, index: H256) -> H256 {
        self.get_original_account(address)
            .and_then(|a| a.get_storage(self.host, &index).ok())
            .unwrap_or(H256::zero())
    }

    fn gas_left(&self) -> U256 {
        self.gas_remaining().into()
    }

    fn gas_price(&self) -> U256 {
        self.effective_gas_price
    }

    fn origin(&self) -> H160 {
        self.origin
    }

    fn block_hash(&self, number: U256) -> H256 {
        // return 0 when block number not in valid range
        // Ref. https://www.evm.codes/#40?fork=shanghai (opcode 0x40)

        match self.block.number.checked_sub(number) {
            Some(block_diff)
                if block_diff <= U256::from(256) && block_diff != U256::zero() =>
            {
                storage::blocks::get_block_hash(self.host, number)
                    .unwrap_or_else(|_| H256::zero())
            }
            _ => H256::zero(),
        }
    }

    fn block_number(&self) -> U256 {
        self.block.number
    }

    fn block_coinbase(&self) -> H160 {
        self.block.coinbase
    }

    fn block_timestamp(&self) -> U256 {
        self.block.timestamp
    }

    fn block_difficulty(&self) -> U256 {
        // There's no difficulty in the blocks
        // A default value is returned here
        U256::zero()
    }

    fn block_gas_limit(&self) -> U256 {
        self.block.gas_limit.into()
    }

    fn block_base_fee_per_gas(&self) -> U256 {
        self.block.base_fee_per_gas()
    }

    fn block_randomness(&self) -> Option<H256> {
        self.block.prevrandao // Always None
    }

    fn chain_id(&self) -> U256 {
        self.block.chain_id
    }

    fn exists(&self, address: H160) -> bool {
        self.code_size(address) > U256::zero()
            || self.get_nonce(address) > U256::zero()
            || self.balance(address) > U256::zero()
    }

    fn deleted(&self, address: H160) -> bool {
        for data in &self.transaction_data {
            if data.deleted_contracts.contains(&address) {
                return true;
            }
        }

        false
    }

    fn is_cold(&mut self, address: H160, index: Option<H256>) -> Result<bool, ExitError> {
        if !self.enable_warm_cold_access {
            return Ok(false);
        }

        match index {
            Some(index) => {
                let is_cold = self.is_storage_hot(address, index).map(|x| !x);
                if let Ok(true) = is_cold {
                    self.mark_storage_as_hot(address, index)?;
                }
                is_cold
            }
            None => {
                if self.precompiles.is_precompile(address) {
                    Ok(false)
                } else {
                    let is_cold = self.is_address_hot(address).map(|x| !x);
                    if let Ok(true) = is_cold {
                        self.mark_address_as_hot(address)?;
                    }
                    is_cold
                }
            }
        }
    }

    fn set_storage(
        &mut self,
        address: H160,
        index: H256,
        value: H256,
    ) -> Result<(), ExitError> {
        let mut account = self.get_or_create_account(address).map_err(|_| {
            ExitError::Other(Cow::from("Could not get account for set_storage"))
        })?;
        account
            .set_storage(self.host, &index, &value)
            .map_err(|_| ExitError::Other(Cow::from("Could not set_storage in handler")))
    }

    fn log(
        &mut self,
        address: H160,
        topics: Vec<H256>,
        data: Vec<u8>,
    ) -> Result<(), ExitError> {
        if let Some(top_data) = self.transaction_data.last_mut() {
            top_data.logs.push(Log {
                address,
                topics,
                data,
            });
            Ok(())
        } else {
            Err(ExitError::Other(Cow::from("No transaction data for log")))
        }
    }

    fn mark_delete(&mut self, address: H160, target: H160) -> Result<(), ExitError> {
        let balance = self.balance(address);

        self.execute_transfer(address, target, balance)
            .map_err(|err| {
                ExitError::Other(Cow::from(
                    "Could not execute transfer on contract delete",
                ))
            })?;

        if let Some(top_data) = self.transaction_data.last_mut() {
            top_data.deleted_contracts.insert(address);

            Ok(())
        } else {
            Err(ExitError::Other(Cow::from(
                "No transaction data for delete",
            )))
        }
    }

    fn create(
        &mut self,
        caller: H160,
        scheme: CreateScheme,
        value: U256,
        init_code: Vec<u8>,
        target_gas: Option<u64>,
    ) -> Capture<CreateOutcome, Self::CreateInterrupt> {
        match self.can_begin_inter_transaction(caller, &value) {
            Precondition::PassPrecondition => {
                // We check that the maximum allowed init code size as specified by EIP-3860
                // can not be reached.
                if let Some(max_initcode_size) = self.config.max_initcode_size {
                    if init_code.len() > max_initcode_size {
                        // [MAX_INIT_CODE_SIZE_RETURN_HACK]
                        // The normal behavior stated by https://www.evm.codes/#f0?fork=shanghai
                        // would be to return a simple error.
                        //  Error cases: [..]
                        //  * size is greater than the chain's maximum initcode size (since Shanghai fork) 
                        //
                        // Unfortunately there is a bug in [evm-runtime-0.39.0] where the `finish_create`
                        // function will always consider error/revert/succed as a "Ok(()) => Control::Continue"
                        // flow which makes it that we can not rollback anything as it should in this case.
                        // The hack-ish way to be able to capture that error and rollback as it should is
                        // to consider this error as fatal and then catch it in `end_inter_transaction`,
                        // rollback what needs to be and then transform the outputed fatal error to a simple
                        // `ExitReason::Error(ExitError::CreateContractLimit)`.

                        return Capture::Exit((
                            ExitReason::Fatal(ExitFatal::CallErrorAsFatal(
                                ExitError::CreateContractLimit,
                            )),
                            None,
                            vec![],
                        ));
                    }
                }

                let gas_limit = self.nested_call_gas_limit(target_gas);

                if let Err(err) = self.record_cost(gas_limit.unwrap_or(0)) {
                    log!(
                        self.host,
                        Debug,
                        "Not enough gas for create. Required at least: {:?}",
                        gas_limit
                    );

                    return Capture::Exit((
                        ExitReason::Error(ExitError::OutOfGas),
                        None,
                        vec![],
                    ));
                }

                // The contract address is created before the increment of the nonce
                // to generate a correct address when the scheme is `Legacy`.
                let contract_address = self.create_address(scheme);

                // This `mark_address_as_hot` must be before the `begin_inter_transaction`
                // so the address will still be hot even if the creation fails
                if self.mark_address_as_hot(contract_address).is_err() {
                    let err = EthereumError::InconsistentState(Cow::from(
                        "Failed to mark callee address as hot",
                    ));
                    return Capture::Exit((
                        ethereum_error_to_exit_reason(&err),
                        None,
                        vec![],
                    ));
                }

                // The nonce of the caller is incremented before the internal tx
                // Even if the internal transaction rollback the nonce will not
                if let Err(err) = self.increment_nonce(caller) {
                    log!(
                        self.host,
                        Debug,
                        "Failed to increment nonce of {:?}",
                        caller
                    );

                    return Capture::Exit((
                        ethereum_error_to_exit_reason(&err),
                        None,
                        vec![],
                    ));
                }
                if let Err(err) = self.begin_inter_transaction(false, gas_limit) {
                    log!(
                        self.host,
                        Debug,
                        "Not enought gas for call. Required at least: {:?}",
                        gas_limit
                    );

                    Capture::Exit((
                        ExitReason::Fatal(ExitFatal::Other(Cow::from(
                            "Out of gas before recursive create",
                        ))),
                        None,
                        vec![],
                    ))
                } else {
                    let result =
                        self.execute_create(caller, value, init_code, contract_address);

                    self.end_inter_transaction(result)
                }
            }
            Precondition::PreconditionErr(exit_reason) => {
                Capture::Exit((exit_reason, None, vec![]))
            }
            Precondition::EthereumErr(err) => {
                Capture::Exit((ethereum_error_to_exit_reason(&err), None, vec![]))
            }
        }
    }

    fn call(
        &mut self,
        code_address: H160,
        transfer: Option<Transfer>,
        input: Vec<u8>,
        target_gas: Option<u64>,
        is_static: bool,
        context: Context,
    ) -> Capture<CallOutcome, Self::CallInterrupt> {
        let transaction_context = TransactionContext::from_context(context);

        // Retrieve value from `Transfer` struct to check if caller has enough balanace
        let value = match transfer {
            None => U256::zero(),
            Some(Transfer { value, .. }) => value,
        };

        match self.can_begin_inter_transaction(transaction_context.context.caller, &value)
        {
            Precondition::PassPrecondition => {
                let mut gas_limit = self.nested_call_gas_limit(target_gas);

                if let Err(err) = self.record_cost(gas_limit.unwrap_or(0)) {
                    log!(
                        self.host,
                        Debug,
                        "Not enough gas for call. Required at least: {:?}",
                        gas_limit
                    );

                    return Capture::Exit((
                        ExitReason::Error(ExitError::OutOfGas),
                        vec![],
                    ));
                }

                // For call with transfer value > 0, a stipend is added to the gaslimit.
                // see yellowpaper, appendix H, opcode CALL (0xf1) and CALLCODE (Oxf2)
                // Note that for other CALL* opcodes sputnik will not add a transfer at all.
                if value > U256::zero() {
                    gas_limit =
                        gas_limit.map(|v| v.saturating_add(self.config.call_stipend));
                }

                if let Err(err) = self.begin_inter_transaction(is_static, gas_limit) {
                    return Capture::Exit((ethereum_error_to_exit_reason(&err), vec![]));
                }

                let result =
                    self.execute_call(code_address, transfer, input, transaction_context);

                match self.end_inter_transaction(result) {
                    Capture::Exit((reason, _, value)) => {
                        log!(self.host, Debug, "Call ended with reason: {:?}", reason);
                        Capture::Exit((reason, value))
                    }
                    Capture::Trap(x) => Capture::Trap(x),
                }
            }
            Precondition::PreconditionErr(exit_reason) => {
                Capture::Exit((exit_reason, vec![]))
            }
            Precondition::EthereumErr(err) => {
                Capture::Exit((ethereum_error_to_exit_reason(&err), vec![]))
            }
        }
    }

    fn pre_validate(
        &mut self,
        context: &Context,
        opcode: Opcode,
        stack: &Stack,
    ) -> Result<(), ExitError> {
        if let Some(cost) = evm::gasometer::static_opcode_cost(opcode) {
            self.record_cost(cost)
        } else {
            let (cost, _target, memory_cost) = evm::gasometer::dynamic_opcode_cost(
                context.address,
                opcode,
                stack,
                self.is_static(),
                self.config,
                self,
            )?;

            self.record_dynamic_cost(cost, memory_cost)
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::account_storage::init_account_storage;
    use crate::precompiles;
    use evm::Config;
    use primitive_types::{H160, H256};
    use std::cmp::Ordering;
    use std::str::FromStr;
    use std::vec;
    use tezos_ethereum::block::BlockFees;
    use tezos_smart_rollup_mock::MockHost;

    const DUMMY_ALLOCATED_TICKS: u64 = 1_000_000;

    fn set_code<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        code: Vec<u8>,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        account.set_code(handler.borrow_host(), &code).unwrap();
    }

    fn get_balance<'a>(handler: &mut EvmHandler<'a, MockHost>, address: &H160) -> U256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.balance(handler.borrow_host()).unwrap()
    }

    fn set_balance<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        new_balance: U256,
    ) {
        let mut account = handler.get_or_create_account(*address).unwrap();
        let old_balance = account.balance(handler.borrow_host()).unwrap();
        match old_balance.cmp(&new_balance) {
            Ordering::Greater => {
                // we require that fund removal goes fine
                assert!(
                    account
                        .balance_remove(handler.borrow_host(), old_balance - new_balance)
                        .unwrap(),
                    "Could not set balance of account"
                )
            }
            Ordering::Less => account
                .balance_add(handler.borrow_host(), new_balance - old_balance)
                .unwrap(),
            Ordering::Equal => (),
        }
    }

    fn get_durable_slot<'a>(
        handler: &mut EvmHandler<'a, MockHost>,
        address: &H160,
        index: &H256,
    ) -> H256 {
        let account = handler.get_or_create_account(*address).unwrap();
        account.get_storage(handler.borrow_host(), index).unwrap()
    }

    fn dummy_first_block() -> BlockConstants {
        let block_fees =
            BlockFees::new(U256::from(12345), U256::from(2_000_000_000_000u64));
        BlockConstants::first_block(U256::zero(), U256::one(), block_fees)
    }

    #[test]
    fn legacy_create_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let gas_price = U256::from(21000);

        // This is a randomly generated address. It has been used for testing legacy address
        // generation with zero nonce using Ethereum. To replicate (with new address):
        // - generate a fresh Ethereum account (on Rinkeby or other test net)
        // - make sure it has eth (transfer from faucet)
        // - check nonce is zero (or bump nonce accordingly below)
        // - create a new contract. Any contract will do.
        // - check address of new contract - it is `expected_result` below.
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let result = handler.create_address(CreateScheme::Legacy { caller });

        let expected_result: H160 =
            H160::from_str("43a61f3f4c73ea0d444c5c1c1a8544067a86219b").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::zero();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("0687a12da0ffa0a64a28c9512512b8ae8870b7ea").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn create2_to_correct_address_nonzero_salt() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let gas_price = U256::from(21000);

        let caller: H160 =
            H160::from_str("9bbfed6889322e016e0a02ee459d306fc19545d8").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let code_hash: H256 = CODE_HASH_DEFAULT;
        let salt: H256 = H256::from_str(
            "0000000000000000000000000000000000000000000000000000000000000001",
        )
        .unwrap();

        let result = handler.create_address(CreateScheme::Create2 {
            caller,
            code_hash,
            salt,
        });

        let expected_result: H160 =
            H160::from_str("dbd0b036a125995a83d0ab020656a8355abac612").unwrap();

        assert_eq!(result, expected_result);
    }

    #[test]
    fn origin_instruction_returns_origin_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(28349_u64);

        // We use an origin distinct from caller for testing purposes
        let origin = H160::from_low_u64_be(117_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            origin,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::ORIGIN.as_u8(), // Push the 32(!) byte origin on to stack (this is "the value")
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            32_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    None,
                    H256::from(origin).0.to_vec(),
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_produces_correct_output() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(28349_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(213_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH32.as_u8(), // Push a 32 byte word onto stack (this is "the value")
            0xFF_u8,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            Opcode::PUSH1.as_u8(), // Push a zero valued word onto stack (this is "the address")
            0_u8,
            Opcode::MSTORE.as_u8(), // Store "the value" at "the address"
            Opcode::PUSH1.as_u8(),  // Push value 2 onto stack - this is "number of bytes"
            2_u8,
            Opcode::PUSH1.as_u8(), // Push value 0 onto stack - this is "the address" again
            0_u8,
            Opcode::RETURN.as_u8(), // Return "number of bytes" at "the address" in the RETURNBUFFER
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    None,
                    vec![0xFF_u8, 0x01_u8],
                );
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_fails_beyond_max_stack_depth() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(2340);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let input_value = U256::from(2026_u32);
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(118);
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address, transfer, input.to_vec(), transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
            }
            Err(err) => {
                panic!(
                    "Expected call to fail because of call depth, but got {:?}",
                    err
                );
            }
        }
    }

    #[test]
    fn contract_call_succeeds_at_maximum_stack_depth() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(8213);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let input_value = U256::from(1025_u32); // transaction depth for contract below is callarg - 1
        let mut input = [0_u8; 32];
        input_value.to_big_endian(&mut input);

        let address = H160::from_low_u64_be(12389);
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            // get input data, subtract one and prepare as argument to nested call
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            0, // call data offset
            Opcode::CALLDATALOAD.as_u8(),
            Opcode::SUB.as_u8(),
            // check if result is zero - if so, skip to return
            Opcode::DUP1.as_u8(),
            Opcode::ISZERO.as_u8(),
            Opcode::PUSH1.as_u8(),
            28_u8, // to JPMDEST
            Opcode::JUMPI.as_u8(),
            // store result in memory to use as call argument
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(),
            // set call parameters
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            32_u8, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0,                       // value
            Opcode::ADDRESS.as_u8(), // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call self
            // when we get here we are done
            Opcode::JUMPDEST.as_u8(),
            Opcode::PUSH1.as_u8(),
            0, // return data size
            Opcode::PUSH1.as_u8(),
            0, // return data offset
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address, transfer, input.to_vec(), transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(444);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(312);
        let input: Vec<u8> = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            46_u8,
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            1_u8,
            Opcode::SLOAD.as_u8(),
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                let expected_in_storage = H256::from_str(
                    "000000000000000000000000000000000000000000000000000000000000002e",
                )
                .unwrap();
                assert_eq!(
                    get_durable_slot(&mut handler, &address, &H256::zero()),
                    expected_in_storage
                );
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_create_can_use_durable_storage() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(117);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let value = U256::zero();
        let create_scheme = CreateScheme::Legacy { caller };
        let init_code: Vec<u8> = hex::decode("608060405234801561001057600080fd5b50602a600081905550610150806100286000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80632e64cec11461003b5780636057361d14610059575b600080fd5b610043610075565b60405161005091906100a1565b60405180910390f35b610073600480360381019061006e91906100ed565b61007e565b005b60008054905090565b8060008190555050565b6000819050919050565b61009b81610088565b82525050565b60006020820190506100b66000830184610092565b92915050565b600080fd5b6100ca81610088565b81146100d557600080fd5b50565b6000813590506100e7816100c1565b92915050565b600060208284031215610103576101026100bc565b5b6000610111848285016100d8565b9150509291505056fea26469706673582212204d6c1853cec27824f5dbf8bcd0994714258d22fc0e0dc8a2460d87c70e3e57a564736f6c63430008120033").unwrap();

        let expected_address = handler.create_address(create_scheme);

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_create(caller, value, init_code, expected_address);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Succeed(ExitSucceed::Returned),
                    Some(expected_address),
                    vec![],
                );
                assert_eq!(result, expected_result);
                assert_eq!(
                    get_durable_slot(&mut handler, &expected_address, &H256::zero()),
                    H256::from_str(
                        "000000000000000000000000000000000000000000000000000000000000002a"
                    )
                    .unwrap()
                );
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_create_has_return_when_revert() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(117);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let value = U256::zero();
        let create_scheme = CreateScheme::Legacy { caller };

        // The code of the contract revert with 0x18 (equivalent to 24)
        let initial_code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0x18,
            Opcode::PUSH1.as_u8(),
            0x00,
            Opcode::MSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0x20,
            Opcode::PUSH1.as_u8(),
            0x00,
            Opcode::REVERT.as_u8(),
        ];

        let contract_address = handler.create_address(create_scheme);
        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_create(caller, value, initial_code, contract_address);

        match result {
            Ok(result) => {
                // Expecting to revert with 0x18 in the return vector
                let expected_result = (
                    ExitReason::Revert(ExitRevert::Reverted),
                    None,
                    vec![
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
                    ],
                );
                assert_eq!(result, expected_result);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_does_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(118);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(117);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address, U256::from(50_u32));
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(101_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Succeed(ExitSucceed::Returned), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &address), U256::from(100_u32));
                assert_eq!(get_balance(&mut handler, &caller), U256::from(1_u32));
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Expected Ok, but got {:?}", err);
            }
        }
    }

    #[test]
    fn contract_call_fails_when_insufficient_funds_for_transfer() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = Some(Transfer {
            source: caller,
            target: address,
            value: U256::from(100_u32),
        });
        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result =
                    (ExitReason::Error(ExitError::OutOfFund), None, vec![]);
                assert_eq!(result, expected_result);
                assert_eq!(get_balance(&mut handler, &caller), U256::from(99_u32));
                assert_eq!(get_balance(&mut handler, &address), U256::zero());
                assert_eq!(handler.gas_used(), 0);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn revert_can_return_a_value() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH8.as_u8(), // push value of return data
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            Opcode::PUSH1.as_u8(), // push address of return data
            0,
            Opcode::MSTORE.as_u8(), // store return data in memory
            Opcode::PUSH1.as_u8(),  // push size of return data
            8,
            Opcode::PUSH1.as_u8(), // push offset in memory of return data
            24,
            Opcode::REVERT.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        match result {
            Ok(result) => {
                let expected_result = (
                    ExitReason::Revert(ExitRevert::Reverted),
                    None,
                    vec![0, 1, 2, 3, 4, 5, 6, 7],
                );
                assert_eq!(expected_result, result);
            }
            Err(err) => {
                panic!("Unexpected error: {:?}", err);
            }
        }
    }

    #[test]
    fn return_hash_of_zero_for_unavailable_block() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let hash_of_unavailable_block = handler.block_hash(U256::zero());
        assert_eq!(H256::zero(), hash_of_unavailable_block)
    }

    #[test]
    fn transactions_fails_if_not_enough_allocated_ticks() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::london();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            10_000,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::PUSH1.as_u8(),
            0u8,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler
            .begin_initial_transaction(false, Some(30000))
            .unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        assert_eq!(
            Err(EthereumError::OutOfTicks),
            result,
            "Contract call was expected to fail and run out of ticks: \n"
        );
    }

    #[test]
    fn store_after_offset_1024() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(), // push value 0xff
            0xff,
            Opcode::PUSH2.as_u8(), // push offset 0x401 == 1025
            0x04,
            0x01,
            Opcode::MSTORE8.as_u8(), // Store 0xff at offset 1025 in memory
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Stopped), None, vec![])),
            result,
            "Writing at offset 1025 in the memory doesn't work"
        )
    }

    #[test]
    fn dont_crash_on_blockhash_instruction() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(210_u64);
        let input = vec![0_u8];
        let transaction_context = TransactionContext::new(caller, address, U256::zero());
        let transfer: Option<Transfer> = None;

        let code: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(), // push value 0x1
            0x1,
            Opcode::PUSH1.as_u8(), // push value 0x0
            0x0,
            Opcode::MSTORE.as_u8(), // a 1 at location 0
            Opcode::PUSH4.as_u8(),  // push value 0xffffffff
            0xff,
            0xff,
            0xff,
            0xff,
            Opcode::BLOCKHASH.as_u8(),
            Opcode::PUSH1.as_u8(), // push value 0x0
            0x0,
            Opcode::MSTORE.as_u8(), // store blockhash at location 0x0
            Opcode::PUSH1.as_u8(),  // push 32
            32,
            Opcode::PUSH1.as_u8(), // push 0x0
            0x0,
            Opcode::RETURN.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result = handler.execute_call(address, transfer, input, transaction_context);

        assert_eq!(
            Ok((
                ExitReason::Succeed(ExitSucceed::Returned),
                None,
                vec![0; 32],
            )),
            result,
        )
    }

    #[test]
    fn prevent_collision_create2_selfdestruct() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();

        let config = Config::shanghai();

        let caller_address: [u8; 20] =
            hex::decode("a94f5374fce5edbc8e2a8697c15331677e6ebf0b")
                .unwrap()
                .try_into()
                .unwrap();
        let caller = H160::from(caller_address);
        let target_address: [u8; 20] =
            hex::decode("ec2c6832d00680ece8ff9254f81fdab0a5a2ac50")
                .unwrap()
                .try_into()
                .unwrap();
        let target_address = H160::from(target_address);

        let transaction_context =
            TransactionContext::new(caller, target_address, U256::zero());

        let gas_price = U256::from(21000);

        // { (CALL 50000 0xec2c6832d00680ece8ff9254f81fdab0a5a2ac50 0 0 0 0 0) (MSTORE 0 0x6460016001556000526005601bf3) (CREATE2 0 18 14 0) }
        let input = hex::decode("6000600060006000600073e2b35478fdd26477cc576dd906e6277761246a3c61c350f1506000600060006000f500").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        // { (SELFDESTRUCT 0x10) }
        let code = hex::decode("6010ff").unwrap();

        set_code(&mut handler, &target_address, code);
        set_balance(&mut handler, &caller, U256::from(1000000000000000000u64));

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(target_address, None, input, transaction_context);

        // This assertion will change with the upcoming Dencun config/fork
        // See: https://eips.ethereum.org/EIPS/eip-6780
        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Suicided), None, vec![],)),
            result,
        );

        let code = handler.code(target_address);
        let balance = handler.balance(target_address);

        assert_eq!(code, vec![96, 16, 255]);
        assert_eq!(balance, U256::zero());
    }

    #[test]
    fn create_contract_with_insufficient_funds() {
        //Init
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let caller = H160::from_str("a94f5374fce5edbc8e2a8697c15331677e6ebf0b").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            U256::one(),
            false,
        );

        set_balance(&mut handler, &caller, U256::from(10000));

        let scheme = CreateScheme::Legacy { caller };
        let code = hex::decode("600c60005566602060406000f060205260076039f3").unwrap();

        let contract_address = handler.create_address(scheme);
        let result =
            handler.execute_create(caller, U256::from(100000), code, contract_address);

        assert_eq!(
            result.unwrap(),
            (ExitReason::Error(ExitError::OutOfFund), None, vec![])
        );
    }

    #[test]
    fn inter_call_with_non_zero_transfer_value_gets_call_stipend() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let address_1 = H160::from_low_u64_be(210_u64);
        let address_2 = H160::from_low_u64_be(211_u64);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address_1, U256::zero());
        let transfer: Option<Transfer> = None;

        let code_1: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            0, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            100, // non-zero value
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::PUSH1.as_u8(),
            0,                    // gas
            Opcode::CALL.as_u8(), // call should suceed and return 1
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(), // store 1 to Memory[0:32]
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            31,
            Opcode::RETURN.as_u8(), // return byte that contains the 1
        ];

        let code_2: Vec<u8> = vec![Opcode::TIMESTAMP.as_u8()];

        set_code(&mut handler, &address_1, code_1);
        set_code(&mut handler, &address_2, code_2);

        set_balance(&mut handler, &caller, U256::from(1000_u32));
        set_balance(&mut handler, &address_1, U256::from(1000_u32));

        handler.begin_initial_transaction(false, None).unwrap();

        let result =
            handler.execute_call(address_1, transfer, input, transaction_context);

        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Returned), None, vec![1],)),
            result,
        )
    }

    #[test]
    fn code_hash_of_zero_for_non_existing_address() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            gas_price,
            false,
        );

        let hash = handler.code_hash(H160::from_low_u64_le(1));

        assert_eq!(H256::zero(), hash)
    }

    #[test]
    fn create_contract_with_selfdestruct_init_code() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let caller = H160::from_str("a94f5374fce5edbc8e2a8697c15331677e6ebf0b").unwrap();
        let withdrawal_contract =
            H160::from_str("2adc25665018aa1fe0e6bc666dac8fc2697ff9ba").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            U256::one(),
            false,
        );

        set_balance(&mut handler, &caller, U256::from(1000000000));

        let code = hex::decode("732adc25665018aa1fe0e6bc666dac8fc2697ff9baff00").unwrap(); // transfer balance to 0x2adc25665018aa1fe0e6bc666dac8fc2697ff9ba and selfdestruct

        let result = handler
            .create_contract(caller, Some(U256::one()), code, None)
            .unwrap();

        let suicided_contract = result.new_address.unwrap();

        assert_eq!(
            result.reason,
            ExitReason::Succeed(ExitSucceed::Suicided).into()
        );
        assert_eq!(get_balance(&mut handler, &withdrawal_contract), U256::one());
        assert_eq!(get_balance(&mut handler, &caller), U256::from(999999999));
        assert!(!handler.exists(suicided_contract));
    }

    #[test]
    fn contract_that_selfdestruct_not_deleted_within_same_transaction() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS * 10000,
            gas_price,
            false,
        );

        let address_1 = H160::from_low_u64_be(210_u64);
        let address_2 = H160::from_low_u64_be(211_u64);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address_1, U256::zero());
        let transfer: Option<Transfer> = None;

        let code_1: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            0, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0, // value
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::PUSH2.as_u8(),
            100,
            0,                    // gas
            Opcode::CALL.as_u8(), // call should cause address 2 to selfdestruct
            Opcode::POP.as_u8(),  // pop return value off the stack
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::EXTCODESIZE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(), // store 1 to Memory[0:32]
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            31,
            Opcode::RETURN.as_u8(), // return codesize of the contract that selfdestruct
        ];

        let code_2: Vec<u8> = vec![Opcode::PUSH1.as_u8(), 0, Opcode::SUICIDE.as_u8()];

        set_code(&mut handler, &address_1, code_1);
        set_code(&mut handler, &address_2, code_2);

        set_balance(&mut handler, &caller, U256::from(1000_u32));
        set_balance(&mut handler, &address_1, U256::from(1000_u32));

        handler
            .begin_initial_transaction(false, Some(1000000))
            .unwrap();

        let result =
            handler.execute_call(address_1, transfer, input, transaction_context);

        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Returned), None, vec![3],)),
            result,
        )
    }

    #[test]
    fn contract_that_selfdestruct_can_be_called_again_in_same_transaction() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS * 10000,
            gas_price,
            false,
        );

        let address_1 = H160::from_low_u64_be(210_u64);
        let address_2 = H160::from_low_u64_be(211_u64);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, address_1, U256::zero());
        let transfer: Option<Transfer> = None;

        let code_1: Vec<u8> = vec![
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            0, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0, // value
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::PUSH2.as_u8(),
            100,
            0,                    // gas
            Opcode::CALL.as_u8(), // call should cause address 2 to selfdestruct
            Opcode::POP.as_u8(),  // pop return value off the stack
            Opcode::PUSH1.as_u8(),
            0, // return size
            Opcode::PUSH1.as_u8(),
            0, // return offset
            Opcode::PUSH1.as_u8(),
            0, // arg size
            Opcode::PUSH1.as_u8(),
            0, // arg offset
            Opcode::PUSH1.as_u8(),
            0, // value
            Opcode::PUSH1.as_u8(),
            211, // address
            Opcode::PUSH2.as_u8(),
            100,
            0,                    // gas
            Opcode::CALL.as_u8(), // call should cause address 2 to selfdestruct
            Opcode::PUSH1.as_u8(),
            0,
            Opcode::MSTORE.as_u8(), // store result to Memory[0:1]
            Opcode::PUSH1.as_u8(),
            1,
            Opcode::PUSH1.as_u8(),
            31,
            Opcode::RETURN.as_u8(), // return result of second call
        ];

        let code_2: Vec<u8> = vec![Opcode::PUSH1.as_u8(), 0, Opcode::SUICIDE.as_u8()];

        set_code(&mut handler, &address_1, code_1);
        set_code(&mut handler, &address_2, code_2);

        set_balance(&mut handler, &caller, U256::from(1000_u32));
        set_balance(&mut handler, &address_1, U256::from(1000_u32));

        handler
            .begin_initial_transaction(false, Some(1000000))
            .unwrap();

        let result =
            handler.execute_call(address_1, transfer, input, transaction_context);

        // The transaction should consume more than twice the cost of a selfdestruct
        assert!(handler.gas_used() > 10000);

        // The second call succeeded
        assert_eq!(
            Ok((ExitReason::Succeed(ExitSucceed::Returned), None, vec![1],)),
            result,
        )
    }

    // According EIP-2929, the created address should still be hot even if the creation fails
    #[test]
    fn address_still_marked_as_hot_after_creation_fails() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();

        let gas_price = U256::from(21000);

        let caller = H160::from_str("a94f5374fce5edbc8e2a8697c15331677e6ebf0b").unwrap();

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS * 10000,
            gas_price,
            true,
        );

        let contrac_addr =
            H160::from_str("095e7baea6a6c7c4c2dfeb977efac326af552d87").unwrap();
        let expected_address = handler.create_address(CreateScheme::Legacy {
            caller: contrac_addr,
        });

        // Tries to CREATE a contract (that will revert)
        let contract_code = vec![
            Opcode::PUSH5.as_u8(),
            0x60,
            0x00,
            0x60,
            0x00,
            0xfd,
            Opcode::PUSH1.as_u8(),
            0x00,
            Opcode::MSTORE.as_u8(),
            Opcode::PUSH1.as_u8(),
            0x05,
            Opcode::PUSH1.as_u8(),
            0x1b,
            Opcode::PUSH1.as_u8(),
            0x00,
            Opcode::CREATE.as_u8(),
        ];
        set_code(&mut handler, &contrac_addr, contract_code);
        let input = vec![0_u8];
        let transaction_context =
            TransactionContext::new(caller, contrac_addr, U256::zero());
        let transfer: Option<Transfer> = None;

        handler
            .begin_initial_transaction(false, Some(1000000))
            .unwrap();

        let _ = handler.execute_call(contrac_addr, transfer, input, transaction_context);

        let exist = handler.is_colliding(expected_address).unwrap();

        assert!(!exist, "Expected address should not exist");

        // After the `execute_call` expected address should be marked as hot
        let is_hot = handler.is_address_hot(expected_address).unwrap();

        assert!(is_hot, "Expected address is cold where it should be hot");
    }

    #[test]
    fn precompile_failure_are_not_fatal() {
        let mut host = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let mut handler = EvmHandler::new(
            &mut host,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS,
            U256::from(21000),
            false,
        );

        handler
            .begin_initial_transaction(false, Some(150000))
            .unwrap();

        handler
            .begin_inter_transaction(false, Some(150000))
            .unwrap();

        let ecmul = H160::from_low_u64_be(7u64);

        // ecmul -> point not on curve fail
        let failing_input = hex::decode(
            "\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            0f00000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();

        let transaction_context = TransactionContext::new(caller, ecmul, U256::zero());

        let result =
            handler.execute_call(ecmul, None, failing_input, transaction_context);

        let inter_result: Capture<CreateOutcome, H160> =
            handler.end_inter_transaction(result);

        // Internal result is not a Fatal case anymore.
        match inter_result {
            Capture::Exit((exit_reason, _, _)) => match exit_reason {
                ExitReason::Error(_) => (),
                e => panic!("The exit reason should be an error but got {:?}.", e),
            },
            Capture::Trap(_) => panic!("The internal result shouldn't be a trap case."),
        }
    }

    #[test]
    fn inner_create_costs_gas() {
        let mut mock_runtime = MockHost::default();
        let block = dummy_first_block();
        let precompiles = precompiles::precompile_set::<MockHost>();
        let mut evm_account_storage = init_account_storage().unwrap();
        let config = Config::shanghai();
        let caller = H160::from_low_u64_be(523_u64);

        let gas_price = U256::from(21000);

        let mut handler = EvmHandler::new(
            &mut mock_runtime,
            &mut evm_account_storage,
            caller,
            &block,
            &config,
            &precompiles,
            DUMMY_ALLOCATED_TICKS * 1000,
            gas_price,
            false,
        );

        let address = H160::from_low_u64_be(210_u64);

        // Create an account with 0 wei and 4 FF as code
        // PUSH13 0x63FFFFFFFF6000526004601CF3
        // PUSH1 0
        // MSTORE
        // PUSH1 13
        // PUSH1 19
        // PUSH1 0
        // CREATE
        // STOP

        let code: Vec<u8> = vec![
            Opcode::PUSH13.as_u8(), // 3 gas
            0x63,
            0xff,
            0xff,
            0xff,
            0xff,
            0x60,
            0x00,
            0x52,
            0x60,
            0x04,
            0x60,
            0x1c,
            0xf3,
            Opcode::PUSH1.as_u8(), // 3 gas
            0,
            Opcode::MSTORE.as_u8(), // 6 gas
            Opcode::PUSH1.as_u8(),  // 3 gas
            13,
            Opcode::PUSH1.as_u8(), // 3 gas
            19,
            Opcode::PUSH1.as_u8(), // 3 gas
            0,
            Opcode::CREATE.as_u8(), // 32000 gas + init_code
            Opcode::STOP.as_u8(),
        ];

        set_code(&mut handler, &address, code);
        set_balance(&mut handler, &caller, U256::from(99_u32));

        let result =
            handler.call_contract(caller, address, None, vec![], Some(1000000), false);

        // Top layers costs 21000 + 3 + 6 + 3 + 3 + 3 + 32000 = 53021 < 53839
        assert_eq!(
            Ok(ExecutionOutcome {
                gas_used: 53839, // costs 53841 on ethereum
                is_success: true,
                reason: ExtendedExitReason::Exit(ExitReason::Succeed(
                    ExitSucceed::Stopped
                )),
                new_address: None,
                logs: vec![],
                result: Some(vec![]),
                withdrawals: vec![],
                estimated_ticks_used: 1484809
            }),
            result,
        )
    }
}
