
./octez-evm-node describe config
{ "log_filter"?:
    { "max_nb_blocks"?:
        integer ∈ [1, 2^30]
        /* The maximum number of blocks that can be visited when executing a
           `eth_getLogs` request. */,
      "max_nb_logs"?:
        integer ∈ [1, 2^30]
        /* The maximum number of logs that can be collected when executing a
           `eth_getLogs` request. */,
      "chunk_size"?:
        integer ∈ [1, 2^30]
        /* Number of blocks to be filter concurrently when executing a
           `eth_getLogs` request. */ },
  "sequencer"?:
    { "time_between_blocks"?:
        $time_between_blocks
        /* The maximum number of seconds separating two consecutive blocks.
           If the TX pool of the sequencer is empty after this duration, an
           empty blueprint is produced. */,
      "max_number_of_chunks"?:
        integer ∈ [1, 128]
        /* Maximum number of chunks a blueprint can be divided into. The
           sequencer will not produce blueprints unable to fit in this limit. */,
      "sequencer": $unistring /* Secret key URI of the sequencer. */,
      "blueprints_publisher_config"?:
        { "max_blueprints_lag"?:
            integer ∈ [1, 2^30]
            /* The number of EVM blocks after which the sequencer considers
               that something went wrong with the injection of a previous
               blueprint. Once reached, the sequencer tries to send them a
               second time. */,
          "max_blueprints_ahead"?:
            integer ∈ [1, 2^30]
            /* The maximum number of EVM blocks that the sequencer accepts to
               create speculatively. If the difference between its head and
               the head of its companion rollup node reaches this number, the
               sequencer will stop creating new blueprints until the rollup
               node has caught up. */,
          "max_blueprints_catchup"?:
            integer ∈ [1, 2^30]
            /* The maximum number of blueprints the sequencer retries to send
               at once whenever its companion rollup node is lagging behind. */,
          "catchup_cooldown"?:
            integer ∈ [1, 2^30]
            /* The number of Layer 1 blocks the sequencer awaits before
               sending another batch of blueprints, as part of its catchup
               mechanism. */,
          "dal_slots"?: [ integer ∈ [-128, 127] ... ] } },
  "threshold_encryption_sequencer"?:
    { "time_between_blocks"?:
        $time_between_blocks
        /* The maximum number of seconds separating two consecutive blocks.
           If the TX pool of the sequencer is empty after this duration, an
           empty blueprint is produced. */,
      "max_number_of_chunks"?: integer ∈ [-2^30, 2^30],
      "sequencer": $unistring /* Secret key URI of the sequencer. */,
      "blueprints_publisher_config"?:
        { "max_blueprints_lag"?:
            integer ∈ [1, 2^30]
            /* The number of EVM blocks after which the sequencer considers
               that something went wrong with the injection of a previous
               blueprint. Once reached, the sequencer tries to send them a
               second time. */,
          "max_blueprints_ahead"?:
            integer ∈ [1, 2^30]
            /* The maximum number of EVM blocks that the sequencer accepts to
               create speculatively. If the difference between its head and
               the head of its companion rollup node reaches this number, the
               sequencer will stop creating new blueprints until the rollup
               node has caught up. */,
          "max_blueprints_catchup"?:
            integer ∈ [1, 2^30]
            /* The maximum number of blueprints the sequencer retries to send
               at once whenever its companion rollup node is lagging behind. */,
          "catchup_cooldown"?:
            integer ∈ [1, 2^30]
            /* The number of Layer 1 blocks the sequencer awaits before
               sending another batch of blueprints, as part of its catchup
               mechanism. */,
          "dal_slots"?: [ integer ∈ [-128, 127] ... ] },
      "sidecar_endpoint"?: $unistring },
  "observer"?:
    { "evm_node_endpoint":
        $unistring
        /* Upstream EVM node endpoint used to fetch speculative blueprints
           and forward incoming transactions. */,
      "threshold_encryption_bundler_endpoint"?: $unistring,
      "rollup_node_tracking"?:
        boolean
        /* Enable or disable monitoring a companion rollup node to verify the
           correctness of the speculative history coming from the upstream
           EVM node. */ },
  "tx_pool_timeout_limit"?:
    $int64
    /* Transaction timeout limit inside the transaction pool */,
  "tx_pool_addr_limit"?:
    $int64
    /* Maximum allowed addresses inside the transaction pool. */,
  "tx_pool_tx_per_addr_limit"?:
    $int64
    /* Maximum allowed transactions per user address inside the transaction
       pool. */,
  "keep_alive"?:
    boolean
    /* Enable or disable if the EVM node retries HTTP requests on failure. */,
  "rollup_node_endpoint"?:
    $unistring
    /* An endpoint to a companion rollup node. It is mainly used to keep
       track of the state of the smart rollup powering the Layer 2 chain. In
       sequencer mode, the blueprint created by the node are forwarded to the
       rollup node to be injected in Layer 1 blocks. */,
  "verbose"?: "info" | "debug" | "error" | "fatal" | "warning" | "notice",
  "experimental_features"?:
    { "drop_duplicate_on_injection"?:
        boolean
        /* Request the rollup node to filter messages it has already
           forwarded to the Layer 1 network. Require an unreleased version of
           the Smart Rollup node. */,
      "enable_send_raw_transaction"?:
        boolean
        /* Enable or disable the `eth_sendRawTransaction` method. DEPRECATED:
            You should use "rpc.restricted_rpcs" instead. */,
      "node_transaction_validation"?: boolean,
      "block_storage_sqlite3"?:
        boolean
        /* Store the blocks and transactions in a sqlite3 database and
           removes them from the durable storage */,
      "overwrite_simulation_tick_limit"?:
        boolean
        /* When enabled, the eth_call method is not subject to the tick
           limit. This can be useful to execute calls that will not be
           injected in transactions (similarly to what the Uniswap V3
           frontend does to prepare swaps). However, it can lead to confusing
           UX for users, where eth_estimateGas fails when eth_call succeeded. */,
      "garbage_collector"?:
        { /* Enables garbage collector in the node. */
          "split_frequency_in_seconds":
            integer ∈ [-2^30, 2^30]
            /* Frequency of irmin context split in seconds */ } },
  "proxy"?:
    { "finalized_view"?:
        boolean
        /* When enabled, the node only expose blocks that are finalized,
           i.e., the `latest` block parameter becomes a synonym for
           `finalized`. DEPRECATED: use the top level `finalized_view` option
           instead. */,
      "evm_node_endpoint"?: $unistring,
      "ignore_block_param"?: boolean },
  "fee_history"?:
    { "max_count"?:
        integer ∈ [1, 2^30]
        /* The maximum number of blocks whose fee history can be retrieved at
           once */,
      "max_past"?:
        integer ∈ [1, 2^30]
        /* The maximum number of blocks in the past where the fee history is
           available */ },
  "kernel_execution"?:
    { "preimages"?:
        $unistring
        /* Path to a directory containing the preimages the kernel can
           reveal. */,
      "preimages_endpoint"?:
        $unistring
        /* Endpoint for downloading the preimages that cannot be found in the
           preimages directory. These preimages are downloaded by the node,
           stored in the preimages directory and fed to the kernel. */ },
  "public_rpc"?:
    { "port"?:
        integer ∈ [1, 2^16-1]
        /* The port used to bind the socket of the RPC server. */,
      "addr"?:
        $unistring
        /* The address used to bind the socket of the RPC server. */,
      "cors_origins"?:
        [ $unistring ... ]
        /* Cross-Origin Resource Sharing (CORS) origin values. See the CORS
           specification. */,
      "cors_headers"?:
        [ $unistring ... ]
        /* Cross-Origin Resource Sharing (CORS) header values. See the CORS
           specification. */,
      "batch_limit"?:
        "unlimited"
        || integer ∈ [-2^30, 2^30]
        /* limited
           Upper bound on the size of a JSON RPC API batch. For batches
           larger than the limit, every request fails. */,
      "restricted_rpcs"?:
        "unrestricted"
        || $unistring
        /* pattern
           Disallow the JSON RPC API methods whose name match this Perl-like
           regexp. */
        || { /* whitelist
                The list of JSON RPC API methods allowed for this server. */
             "whitelist": [ $unistring ... ] }
        || { /* blacklist
                The list of JSON RPC API methods disallowed for this server. */
             "blacklist": [ $unistring ... ] },
      "max_active_connections"?: $max_active_rpc_connections },
  "private_rpc"?:
    { "port"?:
        integer ∈ [1, 2^16-1]
        /* The port used to bind the socket of the RPC server. */,
      "addr"?:
        $unistring
        /* The address used to bind the socket of the RPC server. */,
      "cors_origins"?:
        [ $unistring ... ]
        /* Cross-Origin Resource Sharing (CORS) origin values. See the CORS
           specification. */,
      "cors_headers"?:
        [ $unistring ... ]
        /* Cross-Origin Resource Sharing (CORS) header values. See the CORS
           specification. */,
      "batch_limit"?:
        "unlimited"
        || integer ∈ [-2^30, 2^30]
        /* limited
           Upper bound on the size of a JSON RPC API batch. For batches
           larger than the limit, every request fails. */,
      "restricted_rpcs"?:
        "unrestricted"
        || $unistring
        /* pattern
           Disallow the JSON RPC API methods whose name match this Perl-like
           regexp. */
        || { /* whitelist
                The list of JSON RPC API methods allowed for this server. */
             "whitelist": [ $unistring ... ] }
        || { /* blacklist
                The list of JSON RPC API methods disallowed for this server. */
             "blacklist": [ $unistring ... ] },
      "max_active_connections"?: $max_active_rpc_connections },
  "finalized_view"?:
    boolean
    /* When enabled, the node only expose blocks that are finalized, i.e.,
       the `latest` block parameter becomes a synonym for `finalized`. */ }
$int64:
  /* 64 bit integers
     Decimal representation of 64 bit integers */
  string
$max_active_rpc_connections:
  /* max_active_rpc_connections
     The maximum alowed number of RPC connections */
  "unlimited"
  || integer ∈ [-2^30, 2^30]
  /* limited
     The number of maximum RPC connections allowed is limited to the given
     integer's value. */
$time_between_blocks: number /* Some */ || null /* None */
$unistring:
  /* Universal string representation
     Either a plain UTF8 string, or a sequence of bytes for strings that
     contain invalid byte sequences. */
  string || { "invalid_utf8_string": [ integer ∈ [0, 255] ... ] }
