// SPDX-FileCopyrightText: 2022-2023 TriliTech <contact@trili.tech>
// SPDX-FileCopyrightText: 2023 Functori <contact@functori.com>
//
// SPDX-License-Identifier: MIT

//! Tezos account state and storage

use primitive_types::U256;
use tezos_data_encoding::enc::BinWriter;
use tezos_evm_runtime::runtime::Runtime;
use tezos_smart_rollup::types::Contract;
use tezos_smart_rollup_host::path::{concat, OwnedPath, RefPath};
use tezos_storage::{
    read_u256_le_default, read_u64_le_default, write_u256_le, write_u64_le,
};

use crate::context;

#[derive(Debug, PartialEq)]
pub struct TezlinkImplicitAccount {
    path: OwnedPath,
}

impl From<OwnedPath> for TezlinkImplicitAccount {
    fn from(path: OwnedPath) -> Self {
        Self { path }
    }
}

const BALANCE_PATH: RefPath = RefPath::assert_from(b"/balance");

const COUNTER_PATH: RefPath = RefPath::assert_from(b"/counter");

fn account_path(contract: &Contract) -> Result<OwnedPath, tezos_storage::error::Error> {
    // uses the same encoding as in the octez node's representation of the context
    // see `octez-codec describe alpha.contract binary schema`
    let mut contract_encoded = Vec::new();
    contract
        .bin_write(&mut contract_encoded)
        .map_err(|_| tezos_smart_rollup::host::RuntimeError::DecodingError)?;

    let path_string = alloc::format!("/{}", hex::encode(&contract_encoded));
    Ok(OwnedPath::try_from(path_string)?)
}

impl TezlinkImplicitAccount {
    // We must provide the context object to get the full path in the durable storage
    #[allow(dead_code)]
    pub fn from_contract(
        context: &context::Context,
        contract: &Contract,
    ) -> Result<Self, tezos_storage::error::Error> {
        let index = context::contracts::index(context)?;
        let path = concat(&index, &account_path(contract)?)?;
        Ok(path.into())
    }

    /// Get the **counter** for the Tezlink account.
    #[allow(dead_code)]
    pub fn counter(
        &self,
        host: &impl Runtime,
    ) -> Result<u64, tezos_storage::error::Error> {
        let path = concat(&self.path, &COUNTER_PATH)?;
        read_u64_le_default(host, &path, 0u64)
    }

    /// Set the **counter** for the Tezlink account.
    #[allow(dead_code)]
    pub fn set_counter(
        &mut self,
        host: &mut impl Runtime,
        counter: u64,
    ) -> Result<(), tezos_storage::error::Error> {
        let path = concat(&self.path, &COUNTER_PATH)?;
        write_u64_le(host, &path, counter)
    }

    /// Get the **balance** of an account in Mutez held by the account.
    #[allow(dead_code)]
    pub fn balance(
        &self,
        host: &impl Runtime,
    ) -> Result<U256, tezos_storage::error::Error> {
        let path = concat(&self.path, &BALANCE_PATH)?;
        read_u256_le_default(host, &path, U256::zero())
    }

    /// Set the **balance** of an account in Mutez held by the account.
    #[allow(dead_code)]
    pub fn set_balance(
        &mut self,
        host: &mut impl Runtime,
        balance: U256,
    ) -> Result<(), tezos_storage::error::Error> {
        let path = concat(&self.path, &BALANCE_PATH)?;
        write_u256_le(host, &path, balance)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use std::str::FromStr;
    use tezos_evm_runtime::runtime::MockKernelHost;
    use tezos_smart_rollup::host::Runtime;

    // Read test use hard coded path on purpose to verify the Tezos compatibility.
    // These paths comes from the context.json generated by the create mockup command
    // of octez-client.
    #[test]
    fn test_read_balance() {
        let mut host = MockKernelHost::default();

        let balance = U256::from_str("2944").unwrap();
        // octez-codec decode alpha.contract from '000002298c03ed7d454a101eb7022bc95f7e5f41ac78'
        // Result: "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx"
        let path = RefPath::assert_from(b"/tezlink/context/contracts/index/000002298c03ed7d454a101eb7022bc95f7e5f41ac78/balance");
        let mut balance_array: [u8; 32] = [0; 32];
        balance.to_little_endian(&mut balance_array);
        host.store_write_all(&path, &balance_array).unwrap();

        // Initalize path for Tezlink context at /tezlink/context
        let context = context::Context::init_context();

        // Public key hash in b58 for 000002298c03ed7d454a101eb7022bc95f7e5f41ac78
        let contract = Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
            .expect("Contract base58 conversion should succeed");

        let account = TezlinkImplicitAccount::from_contract(&context, &contract)
            .expect("Account creation should have succeed");

        let read_balance = account
            .balance(&host)
            .expect("read_balance should have succeed");

        assert_eq!(balance, read_balance);
    }

    #[test]
    fn test_read_counter() {
        let mut host = MockKernelHost::default();

        let counter = 3u64;
        // octez-codec decode alpha.contract from '000002298c03ed7d454a101eb7022bc95f7e5f41ac78'
        // Result: "tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx"
        let path = RefPath::assert_from(b"/tezlink/context/contracts/index/000002298c03ed7d454a101eb7022bc95f7e5f41ac78/counter");
        let counter_array: [u8; 8] = counter.to_le_bytes();
        host.store_write_all(&path, &counter_array).unwrap();

        // Initalize path for Tezlink context at /tezlink/context
        let context = context::Context::init_context();

        // Public key hash in b58 for 0002298c03ed7d454a101eb7022bc95f7e5f41ac78
        let contract = Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
            .expect("Contract base58 conversion should succeed");

        let account = TezlinkImplicitAccount::from_contract(&context, &contract)
            .expect("Account creation should have succeed");

        let read_counter = account
            .counter(&host)
            .expect("read_counter should have succeed");

        assert_eq!(counter, read_counter);
    }

    #[test]
    fn test_set_and_read_balance() {
        let mut host = MockKernelHost::default();

        let balance = U256::from_str("4579").unwrap();

        // Initalize path for Tezlink context at /tezlink/context
        let context = context::Context::init_context();

        // Public key hash in b58 for 000002298c03ed7d454a101eb7022bc95f7e5f41ac78
        let contract = Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
            .expect("Contract base58 conversion should succeed");

        let mut account = TezlinkImplicitAccount::from_contract(&context, &contract)
            .expect("Account creation should have succeed");

        let () = account
            .set_balance(&mut host, balance)
            .expect("set_balance should succeed");

        let read_balance = account
            .balance(&host)
            .expect("read_balance should have succeed");

        assert_eq!(balance, read_balance);
    }

    #[test]
    fn test_set_and_read_counter() {
        let mut host = MockKernelHost::default();

        let counter = 6u64;

        // Initalize path for Tezlink context at /tezlink/context
        let context = context::Context::init_context();

        // Public key hash in b58 for 0002298c03ed7d454a101eb7022bc95f7e5f41ac78
        let contract = Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
            .expect("Contract base58 conversion should succeed");

        let mut account = TezlinkImplicitAccount::from_contract(&context, &contract)
            .expect("Account creation should have succeed");

        let () = account
            .set_counter(&mut host, counter)
            .expect("set_counter should have succeed");

        let read_counter = account
            .counter(&host)
            .expect("read_counter should have succeed");

        assert_eq!(counter, read_counter);
    }
}
