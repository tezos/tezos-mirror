// SPDX-FileCopyrightText: 2025 Functori <contact@functori.com>
// SPDX-FileCopyrightText: 2025 Nomadic Labs <contact@nomadic-labs.com>
//
// SPDX-License-Identifier: MIT

use crate::{journal::Journal, precompiles::send_outbox_message::Withdrawal};
use database::EtherlinkVMDB;
use helpers::storage::u256_to_le_bytes;
use inspectors::{
    call_tracer::{CallTracer, CallTracerInput},
    noop::NoInspector,
    struct_logger::{StructLogger, StructLoggerInput},
    EtherlinkInspector, EvmInspection, TracerInput,
};
use precompiles::provider::EtherlinkPrecompiles;
use revm::{
    context::{
        result::{EVMError, ExecutionResult},
        transaction::{AccessList, SignedAuthorization},
        tx::TxEnvBuilder,
        BlockEnv, CfgEnv, ContextTr, DBErrorMarker, Evm, TxEnv,
    },
    context_interface::block::BlobExcessGasAndPrice,
    handler::{instructions::EthInstructions, EthFrame},
    interpreter::interpreter::EthInterpreter,
    primitives::{hardfork::SpecId, Address, Bytes, FixedBytes, TxKind, U256},
    Context, ExecuteCommitEvm, InspectCommitEvm, MainBuilder,
};
use storage::world_state_handler::{account_path, WorldStateHandler};
use tezos_ethereum::block::BlockConstants;
use tezos_evm_logging::{trace, tracing::instrument};
use tezos_evm_runtime::runtime::Runtime;
use tezos_smart_rollup_host::runtime::RuntimeError;
use thiserror::Error;

pub mod inspectors;
pub mod journal;
pub mod layered_state;
pub mod precompiles;
pub mod storage;

mod database;
mod helpers;

pub use helpers::legacy::u256_to_alloy;

#[derive(Error, Debug, PartialEq, Eq, Clone)]
pub enum Error {
    #[error("Runtime error: {0}")]
    Runtime(#[from] RuntimeError),
    #[error("Execution error: {0}")]
    Custom(String),
}

pub(crate) fn custom<E: std::fmt::Display>(e: E) -> Error {
    Error::Custom(e.to_string())
}

impl DBErrorMarker for Error {}

#[derive(Debug, PartialEq)]
pub struct ExecutionOutcome {
    /// Result of the VM transaction execution.
    /// In particular contains gas used and emitted logs.
    pub result: ExecutionResult,
    /// Withdrawals generated by the transaction. This field will be empty if the
    /// transaction fails (or if the transaction doesn't produce any withdrawals).
    pub withdrawals: Vec<Withdrawal>,
}

fn block_env(block_constants: &BlockConstants) -> Result<BlockEnv, Error> {
    // TODO: Whenever the switch to REVM is completely made, readapt BlockConstants
    // structure to match alloy's type. The current structure is highly dependant
    // on what is needed for Sputnik.
    let basefee: u64 = match block_constants.base_fee_per_gas().try_into() {
        Ok(basefee) => basefee,
        Err(err) => {
            return Err(Error::Custom(format!(
                "Invalid base fee per gas conversion: {err:?}"
            )))
        }
    };
    Ok(BlockEnv {
        number: U256::from_le_slice(&u256_to_le_bytes(block_constants.number)),
        beneficiary: Address::from(block_constants.coinbase.0),
        timestamp: U256::from_le_slice(&u256_to_le_bytes(block_constants.timestamp)),
        gas_limit: block_constants.gas_limit,
        basefee,
        difficulty: U256::ZERO,
        prevrandao: Some(
            block_constants
                .prevrandao
                .map(|prevrandao| FixedBytes(prevrandao.0))
                .unwrap_or_default(),
        ),
        blob_excess_gas_and_price: Some(BlobExcessGasAndPrice::new(0, 1)),
    })
}

#[instrument(skip_all)]
#[allow(clippy::too_many_arguments)]
fn tx_env<'a, Host: Runtime>(
    host: &'a mut Host,
    world_state_handler: &'a mut WorldStateHandler,
    caller: Address,
    destination: Option<Address>,
    gas_limit: u64,
    gas_price: u128,
    value: U256,
    data: Bytes,
    access_list: AccessList,
    authorization_list: Option<Vec<SignedAuthorization>>,
    chain_id: u64,
) -> Result<TxEnv, Error> {
    let kind = match destination {
        Some(address) => TxKind::Call(address),
        None => TxKind::Create,
    };

    let storage_account = world_state_handler
        .get_or_create(host, &account_path(&caller)?)
        .map_err(custom)?;
    let info = storage_account.info(host)?;

    // Using the transaction environment builder helps to
    // derive the transaction type directly from the different
    // fields of the transaction.
    let tx_env_builder = TxEnvBuilder::new()
        .caller(caller)
        .gas_limit(gas_limit)
        .gas_price(gas_price)
        .kind(kind)
        .value(value)
        .data(data)
        .nonce(info.nonce)
        .chain_id(Some(chain_id))
        .access_list(access_list);

    let tx_env_builder = match authorization_list {
        Some(authorization_list) => {
            if authorization_list.is_empty() {
                return Err(Error::Custom(
                    "Authorization list cannot be empty per EIP-7702.".to_string(),
                ));
            }
            tx_env_builder.authorization_list_signed(authorization_list)
        }
        None => tx_env_builder,
    };

    let tx_env = tx_env_builder.build().map_err(|err| {
        Error::Custom(format!(
            "Building the transaction environment failed with: {err:?}"
        ))
    })?;

    Ok(tx_env)
}

#[instrument(skip_all)]
fn get_inspector_from(
    tracer_input: TracerInput,
    precompiles: EtherlinkPrecompiles,
    spec_id: SpecId,
) -> EtherlinkInspector {
    match tracer_input {
        TracerInput::CallTracer(CallTracerInput {
            config,
            transaction_hash,
        }) => EtherlinkInspector::CallTracer(Box::new(CallTracer::new(
            config,
            precompiles,
            spec_id,
            transaction_hash,
        ))),
        TracerInput::StructLogger(StructLoggerInput {
            config,
            transaction_hash,
        }) => EtherlinkInspector::StructLogger(Box::new(StructLogger::new(
            config,
            transaction_hash,
        ))),
        TracerInput::NoOp => EtherlinkInspector::NoOp(NoInspector),
    }
}

type EVMInnerContext<'a, Host> = Context<
    &'a BlockEnv,
    &'a TxEnv,
    CfgEnv,
    EtherlinkVMDB<'a, Host>,
    Journal<EtherlinkVMDB<'a, Host>>,
>;

type EvmContext<'a, Host> = Evm<
    EVMInnerContext<'a, Host>,
    (),
    EthInstructions<EthInterpreter, EVMInnerContext<'a, Host>>,
    EtherlinkPrecompiles,
    EthFrame<EthInterpreter>,
>;

#[allow(clippy::too_many_arguments)]
#[instrument(skip_all)]
fn evm_inspect<'a, Host: Runtime>(
    db: EtherlinkVMDB<'a, Host>,
    block: &'a BlockEnv,
    tx: &'a TxEnv,
    precompiles: EtherlinkPrecompiles,
    chain_id: u64,
    spec_id: SpecId,
    inspector: EtherlinkInspector,
    is_simulation: bool,
) -> EvmInspection<'a, Host> {
    let mut cfg = CfgEnv::new().with_chain_id(chain_id).with_spec(spec_id);
    cfg.disable_eip3607 = is_simulation;

    Context::<
        BlockEnv,
        TxEnv,
        CfgEnv,
        EtherlinkVMDB<'a, Host>,
        Journal<EtherlinkVMDB<'a, Host>>,
    >::new(db, spec_id)
    .with_block(block)
    .with_tx(tx)
    .with_cfg(cfg)
    .build_mainnet_with_inspector(inspector)
    .with_precompiles(precompiles)
}

#[instrument(skip_all)]
fn evm<'a, Host: Runtime>(
    db: EtherlinkVMDB<'a, Host>,
    block: &'a BlockEnv,
    tx: &'a TxEnv,
    precompiles: EtherlinkPrecompiles,
    chain_id: u64,
    spec_id: SpecId,
    is_simulation: bool,
) -> EvmContext<'a, Host> {
    let mut cfg = CfgEnv::new().with_chain_id(chain_id).with_spec(spec_id);
    cfg.disable_eip3607 = is_simulation;

    Context::<
        BlockEnv,
        TxEnv,
        CfgEnv,
        EtherlinkVMDB<'a, Host>,
        Journal<EtherlinkVMDB<'a, Host>>,
    >::new(db, spec_id)
    .with_block(block)
    .with_tx(tx)
    .with_cfg(cfg)
    .build_mainnet()
    .with_precompiles(precompiles)
}

#[allow(clippy::too_many_arguments)]
#[instrument(skip_all)]
pub fn run_transaction<'a, Host: Runtime>(
    host: &'a mut Host,
    spec_id: SpecId,
    block_constants: &'a BlockConstants,
    world_state_handler: &'a mut WorldStateHandler,
    precompiles: EtherlinkPrecompiles,
    caller: Address,
    destination: Option<Address>,
    call_data: Bytes,
    gas_limit: u64,
    effective_gas_price: u128,
    value: U256,
    access_list: AccessList,
    authorization_list: Option<Vec<SignedAuthorization>>,
    tracer_input: Option<TracerInput>,
    is_simulation: bool,
) -> Result<ExecutionOutcome, EVMError<Error>> {
    let block_env = block_env(block_constants)?;
    let tx = tx_env(
        host,
        world_state_handler,
        caller,
        destination,
        gas_limit,
        effective_gas_price,
        value,
        call_data,
        access_list,
        authorization_list,
        block_constants.chain_id.as_u64(),
    )?;

    let db = EtherlinkVMDB::new(host, block_constants, world_state_handler)?;

    if let Some(tracer_input) = tracer_input {
        let inspector = get_inspector_from(tracer_input, precompiles.clone(), spec_id);

        let mut evm = evm_inspect(
            db,
            &block_env,
            &tx,
            precompiles,
            block_constants.chain_id.as_u64(),
            spec_id,
            inspector,
            is_simulation,
        );

        let result = evm.inspect_tx_commit(&tx)?;

        if evm.inspector.is_struct_logger() {
            StructLogger::store_outcome(
                evm.ctx.db_mut().host,
                result.is_success(),
                result.output(),
                result.gas_used(),
                evm.inspector.get_transaction_hash(),
            )?
        }

        let withdrawals = evm.db_mut().take_withdrawals();

        Ok(ExecutionOutcome {
            result,
            withdrawals,
        })
    } else {
        let mut evm = evm(
            db,
            &block_env,
            &tx,
            precompiles,
            block_constants.chain_id.as_u64(),
            spec_id,
            is_simulation,
        );

        let execution_result = trace!("evm.transact_commit", evm.transact_commit(&tx))?;

        let withdrawals = evm.db_mut().take_withdrawals();

        if !evm.db_mut().commit_status() {
            // No need to revert the possible database changes because
            // we are in a safe storage.
            return Err(EVMError::Custom(
                "Comitting ended up in an incorrect state change: reverting.".to_owned(),
            ));
        }

        Ok(ExecutionOutcome {
            result: execution_result,
            withdrawals,
        })
    }
}

#[cfg(test)]
mod test {
    use alloy_sol_types::{ContractError, Revert, RevertReason, SolEvent, SolInterface};
    use alloy_sol_types::{SolCall, SolError};
    use nom::AsBytes;
    use primitive_types::H256;
    use revm::context::result::EVMError;
    use revm::{
        context::{
            result::{ExecutionResult, Output},
            transaction::AccessList,
        },
        primitives::{hex::FromHex, Address, Bytes, U256},
        state::{AccountInfo, Bytecode},
    };
    use rlp::Decodable;
    use tezos_crypto_rs::{
        hash::{HashTrait, SecretKeyEd25519},
        public_key::PublicKey,
    };
    use tezos_data_encoding::enc::BinWriter;
    use tezos_evm_runtime::runtime::MockKernelHost;
    use tezos_smart_rollup_host::runtime::Runtime;
    use utilities::{
        block_constants_with_fees, block_constants_with_no_fees, DEFAULT_SPEC_ID,
    };

    use super::Error;
    use crate::helpers::storage::bytes_hash;
    use crate::storage::code::{CodeStorage, EVM_CODES_PATH};
    use crate::test::utilities::CreateAndRevert::{
        createAndRevertCall, CreateAndRevertCalls,
    };
    use crate::test::utilities::RevertCreate;
    use crate::{
        helpers::legacy::FaDepositWithProxy,
        precompiles::{
            change_sequencer_key::{
                ChangeSequencerKey::{change_sequencer_keyCall, ChangeSequencerKeyCalls},
                ChangeSequencerKeyEvent,
            },
            constants::{
                CHANGE_SEQUENCER_KEY_PRECOMPILE_ADDRESS, FA_BRIDGE_SOL_ADDR,
                PRECOMPILE_BURN_ADDRESS, WITHDRAWAL_SOL_ADDR,
            },
            initializer::init_precompile_bytecodes,
        },
        storage::{
            sequencer_key_change::SequencerKeyChange,
            world_state_handler::{
                new_world_state_handler, StorageAccount, SEQUENCER_KEY_CHANGE_PATH,
                SEQUENCER_KEY_PATH, WITHDRAWALS_TICKETER_PATH,
            },
        },
        test::utilities::{
            CallAndRevert::{self, callAndRevertCall},
            FAWithdrawal,
        },
    };
    use crate::{
        precompiles::provider::EtherlinkPrecompiles, run_transaction,
        storage::world_state_handler::account_path, ExecutionOutcome,
    };

    mod utilities {
        use alloy_sol_types::sol;
        use primitive_types::{H160 as PH160, U256 as PU256};
        use revm::primitives::hardfork::SpecId;
        use tezos_ethereum::block::{BlockConstants, BlockFees};

        // The default SpecId is set to Prague.
        // It isn't modular like it was in the previous evm execution.
        // This value was normally retrived from the old execution storage. Once we fully
        // make the switch to REVM this part will become modular again.
        // For now we keep it at Prague which is the latest EVM version Etherlink supports.
        pub(crate) const DEFAULT_SPEC_ID: SpecId = SpecId::PRAGUE;
        const ETHERLINK_CHAIN_ID: u64 = 42793;

        pub(crate) fn block_constants_with_fees() -> BlockConstants {
            BlockConstants::first_block(
                PU256::from(1),
                PU256::from(ETHERLINK_CHAIN_ID),
                BlockFees::new(PU256::from(1), PU256::from(1), PU256::from(1)),
                30_000_000,
                PH160::zero(),
            )
        }

        pub(crate) fn block_constants_with_no_fees() -> BlockConstants {
            BlockConstants::first_block(
                PU256::from(1),
                PU256::from(ETHERLINK_CHAIN_ID),
                BlockFees::new(PU256::zero(), PU256::zero(), PU256::zero()),
                30_000_000,
                PH160::zero(),
            )
        }

        sol! {
            contract CallAndRevert {
                function callAndRevert(address target, bytes callArgs) public {
                    (bool success, bytes memory data) = target.call(callArgs);
                    require(success, "Call failed");
                    revert("Reverting");
                }
            }

            error RevertCreate(address addr);

            contract CreateAndRevert {
                function createAndRevert(bytes memory bytecode) public {
                    address child;
                    assembly{
                        mstore(0x0, bytecode)
                        child := create(0,0xa0, calldatasize())
                    }
                    revert RevertCreate({
                        addr: child
                    });
                }
            }

            contract FAWithdrawal {
                function claim(uint256 deposit_id) external payable;
            }
        }
    }

    #[test]
    fn test_simple_transfer() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_no_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let destination =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();

        let value_sent = U256::from(5);

        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut caller_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        let destination_account = world_state_handler
            .get_or_create(&host, &account_path(&destination).unwrap())
            .unwrap();

        caller_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        let caller_info = caller_account.info(&mut host).unwrap();
        let destination_info = destination_account.info(&mut host).unwrap();
        // Check balances before executing the transfer
        assert_eq!(caller_info.balance, U256::MAX);
        assert_eq!(destination_info.balance, U256::ZERO);

        let execution_result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            Some(destination),
            Bytes::new(),
            30_000_000,
            0,
            value_sent,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        // Check the outcome of the transaction
        match execution_result.result {
            ExecutionResult::Success { .. } => (),
            ExecutionResult::Revert { .. } | ExecutionResult::Halt { .. } => {
                panic!("Simple transfer should have succeeded")
            }
        }

        let caller_info = caller_account.info(&mut host).unwrap();
        assert_eq!(
            caller_info.balance,
            U256::MAX.checked_sub(value_sent).unwrap()
        );
        let destination_info = destination_account.info(&mut host).unwrap();
        assert_eq!(destination_info.balance, value_sent);
    }

    #[test]
    fn test_contract_call_sload_sstore() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let contract =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();

        let value_sent = U256::from(5);

        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut caller_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        caller_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        let mut contract_account = world_state_handler
            .get_or_create(&host, &account_path(&contract).unwrap())
            .unwrap();

        let bytecode = Bytecode::new_raw(Bytes::from_hex("6042600155600154").unwrap());
        let contract_info = AccountInfo {
            balance: U256::ZERO,
            nonce: 0,
            // Code hash will be automatically computed and inserted when
            // inserting the account info into the db.
            code_hash: bytes_hash(bytecode.original_byte_slice()),
            // PUSH1 0x42      # Value to store
            // PUSH1 0x01      # Storage slot index
            // SSTORE          # Store the value in storage
            // PUSH1 0x01      # Load from the same storage slot
            // SLOAD           # Retrieve the value
            code: Some(Bytecode::new_raw(
                Bytes::from_hex("6042600155600154").unwrap(),
            )),
        };

        contract_account.set_info(&mut host, contract_info).unwrap();

        let execution_result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            Some(contract),
            Bytes::new(),
            30_000_000,
            1,
            value_sent,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        // Check the outcome of the transaction
        match execution_result.result {
            ExecutionResult::Success { gas_used, .. } => {
                assert!(gas_used > 0);
            }
            ExecutionResult::Revert { .. } | ExecutionResult::Halt { .. } => {
                panic!("Simple transfer should have succeeded")
            }
        }

        // Check that the storage slot at 0x01 was updated with 0x42
        let storage_slot_value =
            contract_account.get_storage(&host, &U256::from(1)).unwrap();

        assert_eq!(storage_slot_value, U256::from(66));
    }

    #[test]
    fn test_contract_deployment() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        storage_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        let result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            None,
            // # Deployment code for:
            //
            // pragma solidity ^0.8.0;
            //
            // contract StorageAccess {
            //    uint256 public value = 1;
            //
            //    function setValue(uint256 newValue) public {
            //        value = newValue;
            //    }
            // }
            Bytes::from_hex("6080604052600160005534801561001557600080fd5b50610133806100256000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80633fa4f24514603757806355241077146051575b600080fd5b603d6069565b604051604891906090565b60405180910390f35b606760048036038101906063919060d5565b606f565b005b60005481565b8060008190555050565b6000819050919050565b608a816079565b82525050565b600060208201905060a360008301846083565b92915050565b600080fd5b60b5816079565b811460bf57600080fd5b50565b60008135905060cf8160ae565b92915050565b60006020828403121560e85760e760a9565b5b600060f48482850160c2565b9150509291505056fea26469706673582212202dba9d4631e2c42eb5a90449e79df9c7031f4e73f695987b580809d987c057c864736f6c63430008120033").unwrap(),
            30_000_000,
            1,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        );

        match result {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Create(bytecode, Some(address)),
                        ..
                    },
                ..
            }) => {
                let contract_account = world_state_handler
                    .get_or_create(&host, &account_path(&address).unwrap())
                    .unwrap();
                let info = contract_account.info(&mut host).unwrap();

                assert_eq!(
                    bytecode,
                    CodeStorage::new(&info.code_hash)
                        .unwrap()
                        .get_code(&host)
                        .unwrap()
                        .unwrap()
                        .original_bytes()
                )
            }
            other => panic!("ERROR: ended up in {other:?}"),
        }
    }

    #[test]
    fn test_withdrawal_contract() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_no_fees();

        init_precompile_bytecodes(&mut host, &mut world_state_handler).unwrap();

        // Insert account information
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };
        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();
        storage_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        // Store the ticketer address required to build the outbox message
        host.store_write_all(
            &WITHDRAWALS_TICKETER_PATH,
            "KT1BjtrJYcknDALNGhUqtdHwbrFW1AcsUJo4".as_bytes(),
        )
        .unwrap();

        // Call the created address with data generated from:
        // $ cast calldata "withdraw_base58(string)" "tz1fp5ncDmqYwYC568fREYz9iwQTgGQuKZqX"

        let calldata = "0xcda4fee200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000024747a316670356e63446d7159775943353638665245597a3969775154674751754b5a715800000000000000000000000000000000000000000000000000000000";
        let withdrawn_amount = U256::from(1_000_000_000_000u64);

        let ExecutionOutcome {
            result,
            withdrawals,
        } = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(WITHDRAWAL_SOL_ADDR),
            Bytes::from_hex(calldata).unwrap(),
            10_000_000,
            0,
            withdrawn_amount,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        // Verify that:
        //  - caller is deducted
        //  - withdrawal contract burned the received amount
        //  - zero address received the burned amound
        //  - outbox message has been built and sent
        assert!(result.is_success());
        let info = storage_account.info(&mut host).unwrap();
        assert_eq!(info.balance, U256::MAX.saturating_sub(withdrawn_amount));
        let created_account = world_state_handler
            .get_or_create(&host, &account_path(&WITHDRAWAL_SOL_ADDR).unwrap())
            .unwrap();
        let created_account_info = created_account.info(&mut host).unwrap();
        assert_eq!(created_account_info.balance, U256::ZERO);
        let zero_account = world_state_handler
            .get_or_create(&host, &account_path(&PRECOMPILE_BURN_ADDRESS).unwrap())
            .unwrap();
        let zero_account_info = zero_account.info(&mut host).unwrap();
        assert_eq!(zero_account_info.balance, withdrawn_amount);
        let raw_expected_withdrawals = r#"[Standard(AtomicTransactionBatch(OutboxMessageTransactionBatch { batch: [OutboxMessageTransaction { parameters: MichelsonPair(MichelsonContract(Implicit(Ed25519(ContractTz1Hash("tz1fp5ncDmqYwYC568fREYz9iwQTgGQuKZqX")))), Ticket(MichelsonPair(MichelsonContract(Originated(ContractKt1Hash("KT1BjtrJYcknDALNGhUqtdHwbrFW1AcsUJo4"))), MichelsonPair(MichelsonPair(MichelsonNat(Zarith(0)), MichelsonOption(None)), MichelsonInt(Zarith(1)))))), destination: Originated(ContractKt1Hash("KT1BjtrJYcknDALNGhUqtdHwbrFW1AcsUJo4")), entrypoint: Entrypoint { name: "burn" } }] }))]"#;
        assert_eq!(format!("{withdrawals:?}"), raw_expected_withdrawals);
    }

    #[test]
    fn test_call_update_sequencer_key() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_no_fees();

        init_precompile_bytecodes(&mut host, &mut world_state_handler).unwrap();
        // Insert account information
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };
        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();
        storage_account.set_info(&mut host, caller_info).unwrap();

        let private_key = SecretKeyEd25519::from_b58check(
            "edsk31vznjHSSpGExDMHYASz45VZqXN4DPxvsa4hAyY8dHM28cZzp6",
        )
        .unwrap();
        let public_key = PublicKey::from_b58check(
            "edpkuSLWfVU1Vq7Jg9FucPyKmma6otcMHac9zG4oU1KMHSTBpJuGQ2",
        )
        .unwrap();
        let mut public_key_bytes = Vec::new();
        public_key.bin_write(&mut public_key_bytes).unwrap();

        let pk_b58 = PublicKey::to_b58check(&public_key);
        let storage_bytes = String::as_bytes(&pk_b58);
        host.store_write_all(&SEQUENCER_KEY_PATH, storage_bytes)
            .unwrap();
        let signature = private_key.sign(public_key_bytes.clone()).unwrap();
        let signature_bytes = signature.to_bytes().unwrap();
        let calldata =
            ChangeSequencerKeyCalls::change_sequencer_key(change_sequencer_keyCall {
                publicKey: Bytes::copy_from_slice(&public_key_bytes),
                signature: Bytes::copy_from_slice(&signature_bytes),
            })
            .abi_encode();

        let ExecutionOutcome { result, .. } = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(CHANGE_SEQUENCER_KEY_PRECOMPILE_ADDRESS),
            Bytes::copy_from_slice(&calldata),
            10_000_000,
            0,
            U256::MAX,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        assert!(result.logs().len() == 1);
        assert!(
            result
                .logs()
                .first()
                .unwrap()
                .data
                .topics()
                .first()
                .unwrap()
                == &ChangeSequencerKeyEvent::SIGNATURE_HASH
        );
        let value = host.store_read_all(&SEQUENCER_KEY_CHANGE_PATH).unwrap();
        let stored_change = SequencerKeyChange::decode(&rlp::Rlp::new(&value)).unwrap();
        match stored_change {
            change => {
                assert_eq!(change.sequencer_key(), &public_key);
            }
            #[allow(unreachable_patterns)]
            _ => panic!("Expected a Key change"),
        }
    }

    #[test]
    fn test_call_mint_erc20() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        storage_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        let result_create = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            None,
            // # Deployment code for: Tasuku Nakamura's IERC20's contract.
            Bytes::from_hex("60806040526040518060400160405280601381526020017f536f6c6964697479206279204578616d706c6500000000000000000000000000815250600390816200004a91906200033c565b506040518060400160405280600781526020017f534f4c4259455800000000000000000000000000000000000000000000000000815250600490816200009191906200033c565b506012600560006101000a81548160ff021916908360ff160217905550348015620000bb57600080fd5b5062000423565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806200014457607f821691505b6020821081036200015a5762000159620000fc565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302620001c47fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000185565b620001d0868362000185565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b60006200021d620002176200021184620001e8565b620001f2565b620001e8565b9050919050565b6000819050919050565b6200023983620001fc565b62000251620002488262000224565b84845462000192565b825550505050565b600090565b6200026862000259565b620002758184846200022e565b505050565b5b818110156200029d57620002916000826200025e565b6001810190506200027b565b5050565b601f821115620002ec57620002b68162000160565b620002c18462000175565b81016020851015620002d1578190505b620002e9620002e08562000175565b8301826200027a565b50505b505050565b600082821c905092915050565b60006200031160001984600802620002f1565b1980831691505092915050565b60006200032c8383620002fe565b9150826002028217905092915050565b6200034782620000c2565b67ffffffffffffffff811115620003635762000362620000cd565b5b6200036f82546200012b565b6200037c828285620002a1565b600060209050601f831160018114620003b457600084156200039f578287015190505b620003ab85826200031e565b8655506200041b565b601f198416620003c48662000160565b60005b82811015620003ee57848901518255600182019150602085019450602081019050620003c7565b868310156200040e57848901516200040a601f891682620002fe565b8355505b6001600288020188555050505b505050505050565b610d6a80620004336000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806342966c681161007157806342966c681461016857806370a082311461018457806395d89b41146101b4578063a0712d68146101d2578063a9059cbb146101ee578063dd62ed3e1461021e576100a9565b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100fc57806323b872dd1461011a578063313ce5671461014a575b600080fd5b6100b661024e565b6040516100c391906109be565b60405180910390f35b6100e660048036038101906100e19190610a79565b6102dc565b6040516100f39190610ad4565b60405180910390f35b6101046103ce565b6040516101119190610afe565b60405180910390f35b610134600480360381019061012f9190610b19565b6103d4565b6040516101419190610ad4565b60405180910390f35b610152610585565b60405161015f9190610b88565b60405180910390f35b610182600480360381019061017d9190610ba3565b610598565b005b61019e60048036038101906101999190610bd0565b61066f565b6040516101ab9190610afe565b60405180910390f35b6101bc610687565b6040516101c991906109be565b60405180910390f35b6101ec60048036038101906101e79190610ba3565b610715565b005b61020860048036038101906102039190610a79565b6107ec565b6040516102159190610ad4565b60405180910390f35b61023860048036038101906102339190610bfd565b610909565b6040516102459190610afe565b60405180910390f35b6003805461025b90610c6c565b80601f016020809104026020016040519081016040528092919081815260200182805461028790610c6c565b80156102d45780601f106102a9576101008083540402835291602001916102d4565b820191906000526020600020905b8154815290600101906020018083116102b757829003601f168201915b505050505081565b600081600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103bc9190610afe565b60405180910390a36001905092915050565b60005481565b600081600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104629190610ccc565b9250508190555081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104b89190610ccc565b9250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461050e9190610d00565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516105729190610afe565b60405180910390a3600190509392505050565b600560009054906101000a900460ff1681565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105e79190610ccc565b92505081905550806000808282546105ff9190610ccc565b92505081905550600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516106649190610afe565b60405180910390a350565b60016020528060005260406000206000915090505481565b6004805461069490610c6c565b80601f01602080910402602001604051908101604052809291908181526020018280546106c090610c6c565b801561070d5780601f106106e25761010080835404028352916020019161070d565b820191906000526020600020905b8154815290600101906020018083116106f057829003601f168201915b505050505081565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107649190610d00565b925050819055508060008082825461077c9190610d00565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516107e19190610afe565b60405180910390a350565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461083d9190610ccc565b9250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546108939190610d00565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516108f79190610afe565b60405180910390a36001905092915050565b6002602052816000526040600020602052806000526040600020600091509150505481565b600081519050919050565b600082825260208201905092915050565b60005b8381101561096857808201518184015260208101905061094d565b60008484015250505050565b6000601f19601f8301169050919050565b60006109908261092e565b61099a8185610939565b93506109aa81856020860161094a565b6109b381610974565b840191505092915050565b600060208201905081810360008301526109d88184610985565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610a10826109e5565b9050919050565b610a2081610a05565b8114610a2b57600080fd5b50565b600081359050610a3d81610a17565b92915050565b6000819050919050565b610a5681610a43565b8114610a6157600080fd5b50565b600081359050610a7381610a4d565b92915050565b60008060408385031215610a9057610a8f6109e0565b5b6000610a9e85828601610a2e565b9250506020610aaf85828601610a64565b9150509250929050565b60008115159050919050565b610ace81610ab9565b82525050565b6000602082019050610ae96000830184610ac5565b92915050565b610af881610a43565b82525050565b6000602082019050610b136000830184610aef565b92915050565b600080600060608486031215610b3257610b316109e0565b5b6000610b4086828701610a2e565b9350506020610b5186828701610a2e565b9250506040610b6286828701610a64565b9150509250925092565b600060ff82169050919050565b610b8281610b6c565b82525050565b6000602082019050610b9d6000830184610b79565b92915050565b600060208284031215610bb957610bb86109e0565b5b6000610bc784828501610a64565b91505092915050565b600060208284031215610be657610be56109e0565b5b6000610bf484828501610a2e565b91505092915050565b60008060408385031215610c1457610c136109e0565b5b6000610c2285828601610a2e565b9250506020610c3385828601610a2e565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610c8457607f821691505b602082108103610c9757610c96610c3d565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610cd782610a43565b9150610ce283610a43565b9250828203905081811115610cfa57610cf9610c9d565b5b92915050565b6000610d0b82610a43565b9150610d1683610a43565b9250828201905080821115610d2e57610d2d610c9d565b5b9291505056fea264697066735822122066c43ea8566df927073ea47efbfa7f9ed97ebc53ac46b1f05dd52d5af93b50be64736f6c63430008120033").unwrap(),
            30_000_000,
            1,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        );

        let contract_address = match result_create {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Create(_, Some(address)),
                        ..
                    },
                ..
            }) => address,
            other => panic!("ERROR: ended up in {other:?}"),
        };

        let result_call = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(contract_address),
            // # Call data for: Tasuku Nakamura's IERC20's contract 'mint(uint256)' entrypoint.
            Bytes::from_hex("a0712d68000000000000000000000000000000000000000000000000000000000000002a").unwrap(),
            30_000_000,
            1,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        );

        match result_call {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Call(_),
                        ..
                    },
                ..
            }) => (),
            other => panic!("ERROR: ended up in {other:?}"),
        };
    }

    /// Test the revert behavior of the precompile state changes.
    #[test]
    fn test_revert_precompile_state_changes() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_no_fees();
        let deploy_call_and_revert_bytecode = Bytes::from_hex("0x6080604052348015600e575f5ffd5b506103ba8061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610029575f3560e01c8063b1755bc81461002d575b5f5ffd5b610047600480360381019061004291906101f3565b610049565b005b5f5f8473ffffffffffffffffffffffffffffffffffffffff16848460405161007292919061028c565b5f604051808303815f865af19150503d805f81146100ab576040519150601f19603f3d011682016040523d82523d5f602084013e6100b0565b606091505b5091509150816100f5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100ec906102fe565b60405180910390fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161012790610366565b60405180910390fd5b5f5ffd5b5f5ffd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61016182610138565b9050919050565b61017181610157565b811461017b575f5ffd5b50565b5f8135905061018c81610168565b92915050565b5f5ffd5b5f5ffd5b5f5ffd5b5f5f83601f8401126101b3576101b2610192565b5b8235905067ffffffffffffffff8111156101d0576101cf610196565b5b6020830191508360018202830111156101ec576101eb61019a565b5b9250929050565b5f5f5f6040848603121561020a57610209610130565b5b5f6102178682870161017e565b935050602084013567ffffffffffffffff81111561023857610237610134565b5b6102448682870161019e565b92509250509250925092565b5f81905092915050565b828183375f83830152505050565b5f6102738385610250565b935061028083858461025a565b82840190509392505050565b5f610298828486610268565b91508190509392505050565b5f82825260208201905092915050565b7f43616c6c206661696c65640000000000000000000000000000000000000000005f82015250565b5f6102e8600b836102a4565b91506102f3826102b4565b602082019050919050565b5f6020820190508181035f830152610315816102dc565b9050919050565b7f526576657274696e6700000000000000000000000000000000000000000000005f82015250565b5f6103506009836102a4565b915061035b8261031c565b602082019050919050565b5f6020820190508181035f83015261037d81610344565b905091905056fea264697066735822122054a37109eed5c973161a962f99e7485f344af2bc66af38eed5ef05d1c30561ea64736f6c634300081e0033").unwrap();
        init_precompile_bytecodes(&mut host, &mut world_state_handler).unwrap();
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        // Deploy the CallAndRevert contract
        let result_create = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            None,
            deploy_call_and_revert_bytecode,
            30_000_000,
            0,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        );

        let revert_contract_address = match result_create {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Create(_, Some(address)),
                        ..
                    },
                ..
            }) => address,
            other => panic!("ERROR: ended up in {other:?}"),
        };

        // Initialize storage with values useful for FAWithdrawal
        let owner = primitive_types::H160(caller.as_bytes().try_into().unwrap());
        let ticket_hash = H256::zero();
        let default_ticket_balance = U256::from(1);
        let deposit = FaDepositWithProxy {
            amount: primitive_types::U256::from(1000),
            proxy: owner,
            ticket_hash,
            ..Default::default()
        };
        let id = U256::ZERO;
        let mut account_zero = StorageAccount::get_or_create_account(
            &host,
            &world_state_handler,
            Address::ZERO,
        )
        .unwrap();
        account_zero.write_deposit(&mut host, deposit, id).unwrap();
        account_zero
            .write_ticket_balance(
                &mut host,
                &U256::from_be_bytes(ticket_hash.0),
                &caller,
                default_ticket_balance,
            )
            .unwrap();

        // Prepare call to FAWithdrawal claim function
        let calldata = FAWithdrawal::FAWithdrawalCalls::claim(FAWithdrawal::claimCall {
            deposit_id: id,
        })
        .abi_encode();
        let call_and_revert_call =
            CallAndRevert::CallAndRevertCalls::callAndRevert(callAndRevertCall {
                callArgs: Bytes::from(calldata),
                target: FA_BRIDGE_SOL_ADDR,
            });

        // Insert account information
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };
        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();
        storage_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        // Call the CallAndRevert contract with the calldata for FAWithdrawal
        let ExecutionOutcome {
            result,
            withdrawals: _,
        } = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(revert_contract_address),
            Bytes::from(call_and_revert_call.abi_encode()),
            10_000_000,
            0,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        // Check for revert reason match the one from CallAndRevert
        match result {
            ExecutionResult::Revert { output, .. } => {
                assert_eq!(
                    RevertReason::decode(&output).unwrap(),
                    RevertReason::ContractError(ContractError::Revert(Revert {
                        reason: "Reverting".into()
                    }))
                );
            }
            other => panic!("ERROR: ended up in {other:?}"),
        }

        let storage_account = StorageAccount::get_or_create_account(
            &host,
            &world_state_handler,
            Address::ZERO,
        )
        .unwrap();

        // Should still be present because reverting cancelled the usage of this deposit
        storage_account.read_deposit_from_queue(&host, &id).unwrap();

        // Check that ticket balance didn't increased
        assert_eq!(
            storage_account
                .read_ticket_balance(&host, &U256::from_be_bytes(ticket_hash.0), &caller)
                .unwrap(),
            default_ticket_balance
        );
    }

    #[test]
    fn test_revert_delete_created_bytecode() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        world_state_handler.begin_transaction(&mut host).unwrap();
        let block_constants = block_constants_with_no_fees();
        let deploy_create_and_revert_bytecode = Bytes::from_hex("0x6080604052348015600e575f5ffd5b506102b38061001c5f395ff3fe608060405234801561000f575f5ffd5b5060043610610029575f3560e01c80634f8c2d0e1461002d575b5f5ffd5b610047600480360381019061004291906101de565b610049565b005b5f815f523660a05ff09050806040517f9f8aa6e50000000000000000000000000000000000000000000000000000000081526004016100889190610264565b60405180910390fd5b5f604051905090565b5f5ffd5b5f5ffd5b5f5ffd5b5f5ffd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b6100f0826100aa565b810181811067ffffffffffffffff8211171561010f5761010e6100ba565b5b80604052505050565b5f610121610091565b905061012d82826100e7565b919050565b5f67ffffffffffffffff82111561014c5761014b6100ba565b5b610155826100aa565b9050602081019050919050565b828183375f83830152505050565b5f61018261017d84610132565b610118565b90508281526020810184848401111561019e5761019d6100a6565b5b6101a9848285610162565b509392505050565b5f82601f8301126101c5576101c46100a2565b5b81356101d5848260208601610170565b91505092915050565b5f602082840312156101f3576101f261009a565b5b5f82013567ffffffffffffffff8111156102105761020f61009e565b5b61021c848285016101b1565b91505092915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f61024e82610225565b9050919050565b61025e81610244565b82525050565b5f6020820190506102775f830184610255565b9291505056fea264697066735822122053059908becc543c4f8d8f401652f4888f3e356e7d1c6567a4f53fcdf0ea6ea364736f6c634300081e0033").unwrap();
        init_precompile_bytecodes(&mut host, &mut world_state_handler).unwrap();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        // Deploy the CreateAndRevert contract
        let result_create = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            None,
            deploy_create_and_revert_bytecode,
            30_000_000,
            0,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        );
        world_state_handler.commit_transaction(&mut host).unwrap();

        let revert_contract_address = match result_create {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Create(_, Some(address)),
                        ..
                    },
                ..
            }) => address,
            other => panic!("ERROR: ended up in {other:?}"),
        };

        let create_and_revert_call =
            CreateAndRevertCalls::createAndRevert(createAndRevertCall {
                bytecode: Bytes::from_hex("0x6080604052348015600e575f5ffd5b50606a80601a5f395ff3fe6080604052348015600e575f5ffd5b50600436106026575f3560e01c80636b59084d14602a575b5f5ffd5b60306032565b005b56fea2646970667358221220e7c453431baacca104fa0d26c8d9fb06266545148b18a79c3ed740ce52d16a0a64736f6c634300081e0033").unwrap()
            });

        let nb_contract_before_deploy =
            host.store_count_subkeys(&EVM_CODES_PATH).unwrap();

        // Call the CallAndRevert contract with the calldata for FAWithdrawal
        let ExecutionOutcome {
            result,
            withdrawals: _,
        } = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(revert_contract_address),
            Bytes::from(create_and_revert_call.abi_encode()),
            10_000_000,
            0,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        // Get the address where the bytecode should have been deployed
        let addr_deployed_bytecode = match result {
            ExecutionResult::Revert { output, .. } => {
                RevertCreate::abi_decode(&output).unwrap().addr
            }
            other => panic!("ERROR: ended up in {other:?}"),
        };

        assert!(StorageAccount::get_account(
            &host,
            &mut world_state_handler,
            addr_deployed_bytecode
        )
        .unwrap()
        .is_none());
        assert!(
            nb_contract_before_deploy
                == host.store_count_subkeys(&EVM_CODES_PATH).unwrap()
        );
    }

    #[test]
    fn test_store_and_claim_fa_deposit_wrong_id() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_no_fees();

        init_precompile_bytecodes(&mut host, &mut world_state_handler).unwrap();

        // Initialize dummy deposit, store it in the deposits table with id 1

        let dummy_deposit = FaDepositWithProxy::default();

        let deposit_id = U256::ONE;

        let mut system = world_state_handler
            .get_or_create(&host, &account_path(&Address::ZERO).unwrap())
            .unwrap();

        system
            .write_deposit(&mut host, dummy_deposit, deposit_id)
            .unwrap();

        // Initialize caller with infinite balance to claim deposit

        let initial_balance = U256::MAX;

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: initial_balance,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut caller_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        caller_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        // Claim deposit with id 2 (wrong id), revert is expected

        run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(FA_BRIDGE_SOL_ADDR),
            FAWithdrawal::claimCall {
                deposit_id: U256::from(2),
            }
            .abi_encode()
            .into(),
            30_000_000,
            0,
            U256::ZERO,
            AccessList(vec![]),
            None,
            None,
            false,
        )
        .unwrap();

        let caller_account_info = caller_account.info(&mut host).unwrap();
        assert_eq!(initial_balance, caller_account_info.balance);
    }

    #[test]
    fn test_empty_authorization_list_are_prohibited() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_no_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let destination =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();

        let value_sent = U256::from(5);

        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut caller_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        let destination_account = world_state_handler
            .get_or_create(&host, &account_path(&destination).unwrap())
            .unwrap();

        caller_account
            .set_info_without_code(&mut host, caller_info)
            .unwrap();

        let caller_info = caller_account.info(&mut host).unwrap();
        let destination_info = destination_account.info(&mut host).unwrap();
        // Check balances before executing the transfer
        assert_eq!(caller_info.balance, U256::MAX);
        assert_eq!(destination_info.balance, U256::ZERO);

        let result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            Some(destination),
            Bytes::new(),
            30_000_000,
            0,
            value_sent,
            AccessList(vec![]),
            Some(vec![]),
            None,
            false,
        );

        assert_eq!(
            result,
            Err(EVMError::Database(Error::Custom(
                "Authorization list cannot be empty per EIP-7702.".to_owned()
            )))
        );
    }
}
