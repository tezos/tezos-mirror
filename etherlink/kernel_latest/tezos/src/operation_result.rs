// SPDX-FileCopyrightText: 2025 Functori <contact@functori.com>
//
// SPDX-License-Identifier: MIT

//! Tezos operations

use crate::lazy_storage_diff::LazyStorageDiffList;
use crate::operation::{
    ManagerOperation, ManagerOperationContent, ManagerOperationContentConv,
    OperationContent, OriginationContent, RevealContent, TransferContent,
};
use mir::ast::Entrypoint;
use mir::gas;
/// The whole module is inspired of `src/proto_alpha/lib_protocol/apply_result.ml` to represent the result of an operation
/// In Tezlink, operation is equivalent to manager operation because there is no other type of operation that interests us.
use nom::error::ParseError;
use std::fmt::Debug;
use tezos_crypto_rs::hash::ContractKt1Hash;
use tezos_crypto_rs::hash::UnknownSignature;
use tezos_crypto_rs::CryptoError;
use tezos_data_encoding::enc as tezos_enc;
use tezos_data_encoding::nom as tezos_nom;
use tezos_data_encoding::nom::error::DecodeError;
use tezos_data_encoding::types::Narith;
use tezos_data_encoding::types::Zarith;
use tezos_enc::BinWriter;
use tezos_nom::NomReader;
use tezos_protocol::contract::Contract;
use tezos_smart_rollup::types::{PublicKey, PublicKeyHash};
use tezos_smart_rollup_host::runtime::RuntimeError;
use thiserror::Error;

#[derive(Debug, PartialEq, Eq, NomReader, BinWriter)]
pub struct CounterError {
    pub expected: Narith,
    pub found: Narith,
}

#[derive(Error, Debug, PartialEq, Eq, NomReader, BinWriter)]
pub enum ValidityError {
    #[error("Counter in the past: {0:?}.")]
    CounterInThePast(CounterError),
    #[error("Counter in the future: {0:?}.")]
    CounterInTheFuture(CounterError),
    #[error("The manager key for {0} has not been revealed yet.")]
    UnrevealedManagerKey(PublicKeyHash),
    #[error("Cannot pay {0:?} in fees.")]
    CantPayFees(Narith),
    #[error("Empty implicit contract.")]
    EmptyImplicitContract,
    #[error("Storage limit is too high.")]
    StorageLimitTooHigh,
    #[error("Invalid signature.")]
    InvalidSignature,
    #[error("Failed to fetch account")]
    FailedToFetchAccount,
    #[error("Failed to compute fee balance update")]
    FailedToComputeFeeBalanceUpdate,
    #[error("Failed to fetch counter")]
    FailedToFetchCounter,
    #[error("Failed to fetch manager key")]
    FailedToFetchManagerKey,
    #[error("Failed to fetch balance")]
    FailedToFetchBalance,
    #[error("Failed to update balance")]
    FailedToUpdateBalance,
    #[error("Failed to increment counter.")]
    FailedToIncrementCounter,
    #[error("Batch is empty.")]
    EmptyBatch,
    #[error("Batch contains operations from multiple sources.")]
    MultipleSources,
    #[error("Cannot set gas limit due to : {0}")]
    GasLimitSetError(String),
    #[error("Gas exhaustion")]
    OutOfGas,
    #[error("Operation not supported")]
    UnsupportedOperation,
}

impl From<gas::OutOfGas> for ValidityError {
    fn from(_: gas::OutOfGas) -> Self {
        ValidityError::OutOfGas
    }
}

impl From<CryptoError> for ValidityError {
    fn from(_: CryptoError) -> Self {
        ValidityError::InvalidSignature
    }
}

#[derive(Error, Debug, PartialEq, Eq, NomReader, BinWriter)]
pub enum RevealError {
    #[error("Revelation failed because the public key {0} was already revealed.")]
    PreviouslyRevealedKey(PublicKey),
    #[error("The public key hash {0} is inconsistent.")]
    InconsistentHash(PublicKeyHash),
    #[error("The public key hash {0} is inconsistent with the public key provided.")]
    InconsistentPublicKey(PublicKeyHash),
    #[error("Could not retrieve manager.")]
    UnretrievableManager,
    #[error("Failed to write manager.")]
    FailedToWriteManager,
}

#[derive(thiserror::Error, Debug, PartialEq, Eq, BinWriter, NomReader)]
#[error("{contract:?} cannot spend {amount:?} as its balance is {balance:?}")]
pub struct BalanceTooLow {
    pub contract: Contract,
    pub balance: Narith,
    pub amount: Narith,
}

#[derive(Error, Debug, PartialEq, Eq, BinWriter, NomReader)]
pub enum TransferError {
    #[error(transparent)]
    BalanceTooLow(BalanceTooLow),
    #[error("{0:?} is unspendable")]
    UnspendableContract(Contract),
    #[error("Called a non-smart contract with parameter")]
    NonSmartContractExecutionCall,
    // TODO: #8003 propagate the error generated by MIR
    #[error("Apply operation failed because of micheline decoding {0}")]
    MichelineDecodeError(String),
    // TODO: #8003 propagate the error generated by MIR
    #[error("Failed interpreting the Michelson contract with {0}")]
    MichelsonContractInterpretError(String),
    // TODO: #8003 propagate the error generated by MIR
    #[error("Mir failed to typecheck the contract with {0}")]
    MirTypecheckingError(String),
    #[error("Failed to allocate destination")]
    FailedToAllocateDestination,
    #[error("Failed to compute balance update due to new balance overflow")]
    FailedToComputeBalanceUpdate,
    #[error("Failed to apply balance changes")]
    FailedToApplyBalanceChanges,
    #[error("Failed to fetch destination account")]
    FailedToFetchDestinationAccount,
    #[error("Failed to fetch contract code")]
    FailedToFetchContractCode,
    #[error("Failed to fetch contract storage")]
    FailedToFetchContractStorage,
    #[error("Failed to fetch destination balance")]
    FailedToFetchDestinationBalance,
    #[error("Failed to fetch sender balance")]
    FailedToFetchSenderBalance,
    #[error("Failed to update contract storage")]
    FailedToUpdateContractStorage,
    #[error("Failed to update destination balance")]
    FailedToUpdateDestinationBalance,
    #[error("Apply operation failed because of an unsupported address error")]
    MirAddressUnsupportedError,
    #[error("Failed to execute internal operation: {0}")]
    FailedToExecuteInternalOperation(String),
    #[error("Failed to convert amount to Narith: {0}")]
    MirAmountToNarithError(String),
    #[error("Failed to convert Narith to amount: {0}")]
    MirNarithToAmountError(String),
    #[error("Transactions of 0 tez towards a contract without code are forbidden")]
    EmptyImplicitTransfer,
    #[error("Gas exhaustion")]
    OutOfGas,
    #[error("Unexpected deposit error: {0}")]
    DepositError(String),
    #[error("Gateway problem: {0}")]
    GatewayError(String),
}

#[derive(Error, Debug, PartialEq, Eq, NomReader)]
pub enum OriginationError {
    #[error("Failed to fetch source account")]
    FailedToFetchSourceAccount,
    #[error("Failed to fetch originated smart contract")]
    FailedToFetchOriginated,
    #[error("Failed to compute balance update")]
    FailedToComputeBalanceUpdate,
    #[error("Failed to applied balance update")]
    FailedToApplyBalanceUpdate,
    #[error("Can't initialize smart contract")]
    CantInitContract,
    #[error("Can't originate an empty smart contract")]
    CantOriginateEmptyContract,
    #[error("Mir failed to allocate big_map because {0}")]
    MirBigMapAllocation(String),
    #[error("Mir failed to typecheck the contract with {0}")]
    MirTypecheckingError(String),
    #[error("Failed because of micheline decoding {0}")]
    MichelineDecodeError(String),
}

impl From<mir::serializer::DecodeError> for TransferError {
    fn from(err: mir::serializer::DecodeError) -> Self {
        Self::MichelineDecodeError(err.to_string())
    }
}

impl From<mir::interpreter::ContractInterpretError<'_>> for TransferError {
    fn from(err: mir::interpreter::ContractInterpretError) -> Self {
        Self::MichelsonContractInterpretError(err.to_string())
    }
}

impl From<mir::typechecker::TcError> for TransferError {
    fn from(err: mir::typechecker::TcError) -> Self {
        Self::MirTypecheckingError(err.to_string())
    }
}

#[derive(Error, Debug, PartialEq, Eq)]
pub enum ApplyOperationError {
    #[error("Reveal error: {0}")]
    Reveal(#[from] RevealError),
    #[error("Transfer error: {0}")]
    Transfer(#[from] TransferError),
    #[error("Origination error: {0}")]
    Origination(#[from] OriginationError),
    #[error("Smart-Contract emitted an event, which is unsupported: {0}")]
    UnSupportedEmit(String),
    #[error("Set delegate operation is unsupported: {0}")]
    UnSupportedSetDelegate(String),
    #[error("Internal operation nonce overflow due to {0}")]
    InternalOperationNonceOverflow(String),
    // This error variant is used to encapsulate errors that were generated in the past and encoded as bson.
    // It should not be used for new errors, which should be added as new variants to this enum.
    // This is a temporary solution while waiting for better error support.
    #[error("")]
    PastError(Vec<u8>),
}

#[derive(Error, Debug, PartialEq, Eq)]
pub enum OperationError {
    #[error("Validation error: {0}")]
    Validation(#[from] ValidityError),
    #[error("Runtime error: {0}")]
    RuntimeError(#[from] RuntimeError),
}

fn elements_to_bson(elts: &[(&[u8], &[u8])]) -> Vec<u8> {
    // As per the BSON specification (https://bsonspec.org/spec.html), the BSON
    // document is made of the concatenation of the following values:
    //   * its full size encoded on 4 little-endian bytes, including
    //     the size itself;
    //   * its concatenated fields (the contents of the document);
    //   * the byte 0.

    let mut document = vec![];
    let mut contents = vec![];
    for (key, value) in elts {
        // Tag 2 for a field of type string.
        contents.push(0x02);
        // The key does not require a size prefix.
        contents.extend_from_slice(key);
        // The 0 byte terminates the key.
        contents.push(0x00);
        // The value is also suffixed by the 0 byte and contrary to the key it is
        // prefixed by its size (including the 0 byte, hence the + 1).
        contents.extend_from_slice(&(value.len() as u32 + 1).to_le_bytes());
        contents.extend_from_slice(value);
        contents.push(0x00);
    }

    // The size here is the size of the whole document, including the trailing 0
    // byte and the 4 bytes used to represent the size itself (hence the + 5).
    document.extend_from_slice(&(contents.len() as u32 + 5).to_le_bytes());
    document.extend_from_slice(&contents);
    document.push(0x00);
    document
}

// In Tezos data encoding, errors are encoded as bson (binary json). Unfortunately,
// we cannot use the rust binary json crate to produce compatible bson data because
// this crate uses Float pointer instructions (which is incompatible with the PVM).
// To avoid reimplementing full bson support, we restrict the encoding of errors
// to a single bson structure. This gives us error which can be decoded using
// Tezos data encoding but with less possibilities than what Tezos L1 produces.
// For compatibility with the TzKT indexer, we need to produce a BSON object with
// an "id" field (see https://github.com/baking-bad/tzkt/blob/master/Tzkt.Sync/Protocols/Helpers/OperationErrors.cs).
// We use the following structure:
// { "kind": "permanent", "id": "tezlink_error", "error_message": "<error>" }
// This is a temporary solution while waiting for better error support.
// TODO https://linear.app/tezos/issue/L2-363/l1tzkt-compatible-errors
impl BinWriter for ApplyOperationError {
    fn bin_write(&self, output: &mut Vec<u8>) -> tezos_enc::BinResult {
        tezos_enc::dynamic(|error: &ApplyOperationError, out: &mut Vec<u8>| {
            match *error {
                ApplyOperationError::PastError(ref bytes) => {
                    tezos_enc::bytes(bytes, out)?
                }
                _ => {
                    let str_error = format!("{error:?}");
                    let encoded_str_error = str_error.as_bytes();
                    let bson = elements_to_bson(&[
                        (b"kind", b"permanent"),
                        (b"id", b"tezlink_error"),
                        (b"error_message", encoded_str_error),
                    ]);
                    tezos_enc::bytes(bson, out)?;
                }
            }
            Ok(())
        })(self, output)
    }
}

// As we're encoding the OperationError with a single String, the NomReader function is broken.
// For now, we decode them as a PastError with the raw bytes.
impl NomReader<'_> for ApplyOperationError {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        tezos_nom::dynamic(|bytes| {
            Ok((&[], ApplyOperationError::PastError(bytes.to_vec())))
        })(input)
    }
}

// As we're encoding the OperationError with a single String, the NomReader function is broken.
// This is not an issue TODO: https://linear.app/tezos/issue/L2-834/errors-are-dropped-in-tezos-blocks
impl NomReader<'_> for OperationError {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        Err(nom::Err::Error(DecodeError::from_error_kind(
            input,
            nom::error::ErrorKind::Fail,
        )))
    }
}

pub trait OperationKind {
    type Success: PartialEq + Debug + BinWriter + for<'a> NomReader<'a>;
}

impl OperationKind for TransferContent {
    type Success = TransferTarget;
}
impl OperationKind for RevealContent {
    type Success = RevealSuccess;
}

impl OperationKind for OriginationContent {
    type Success = OriginationSuccess;
}

impl OperationKind for EventContent {
    type Success = EventSuccess;
}

// Inspired from `src/proto_alpha/lib_protocol/apply_results.ml` : transaction_contract_variant_cases
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum TransferTarget {
    ToContrat(TransferSuccess),
}

impl From<TransferSuccess> for TransferTarget {
    fn from(value: TransferSuccess) -> Self {
        TransferTarget::ToContrat(value)
    }
}

impl From<TransferTarget> for TransferSuccess {
    fn from(value: TransferTarget) -> Self {
        match value {
            TransferTarget::ToContrat(success) => success,
        }
    }
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct RevealSuccess {
    pub consumed_milligas: Narith,
}

// PlaceHolder Type for temporary unused fields
#[derive(PartialEq, Debug)]
pub struct Empty;

impl BinWriter for Empty {
    fn bin_write(&self, _: &mut Vec<u8>) -> tezos_enc::BinResult {
        Ok(())
    }
}

impl NomReader<'_> for Empty {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        Ok((input, Self))
    }
}

// alpha.contract_id.originated (22 bytes, 8-bit tag)
// **************************************************
//
// Originated (tag 1)
// ==================
//
// +---------------+----------+------------------------+
// | Name          | Size     | Contents               |
// +===============+==========+========================+
// | Tag           | 1 byte   | unsigned 8-bit integer |
// +---------------+----------+------------------------+
// | Contract_hash | 20 bytes | bytes                  |
// +---------------+----------+------------------------+
// | padding       | 1 byte   | padding                |
// +---------------+----------+------------------------+
//
// The encoding of the alpha.contract_id.originated type is the same as
// the one implemented in the kernel_sdk Contract. However, this type
// cannot be an implicit account. Therefore, we created a new type that
// only holds a KT1. The new type reuses the existing functions.
#[derive(PartialEq, Debug, Clone)]
pub struct Originated {
    pub contract: ContractKt1Hash,
}

impl BinWriter for Originated {
    fn bin_write(&self, output: &mut Vec<u8>) -> tezos_enc::BinResult {
        let contract = Contract::Originated(self.contract.clone());
        contract.bin_write(output)
    }
}

impl NomReader<'_> for Originated {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        let (input, contract) = Contract::nom_read(input)?;
        match contract {
            Contract::Originated(kt1h) => Ok((input, Originated { contract: kt1h })),
            Contract::Implicit(_) => Err(nom::Err::Error(DecodeError::from_error_kind(
                input,
                nom::error::ErrorKind::Fail,
            ))),
        }
    }
}

// Inspired of src/proto_023_PtSeouLo/lib_protocol/apply_internal_result.mli
#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct OriginationSuccess {
    #[encoding(dynamic, list)]
    pub balance_updates: Vec<BalanceUpdate>,
    #[encoding(dynamic, list)]
    pub originated_contracts: Vec<Originated>,
    pub consumed_milligas: Narith,
    pub storage_size: Zarith,
    pub paid_storage_size_diff: Zarith,
    pub lazy_storage_diff: Option<LazyStorageDiffList>,
}

#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct TransferSuccess {
    #[encoding(option, bytes)]
    pub storage: Option<Vec<u8>>,
    #[encoding(dynamic, list)]
    pub balance_updates: Vec<BalanceUpdate>,
    #[encoding(dynamic, bytes)]
    pub ticket_receipt: Vec<u8>,
    #[encoding(dynamic, bytes)]
    pub originated_contracts: Vec<u8>,
    pub consumed_milligas: Narith,
    pub storage_size: Zarith,
    pub paid_storage_size_diff: Zarith,
    pub allocated_destination_contract: bool,
    pub lazy_storage_diff: Option<LazyStorageDiffList>,
}

#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct EventSuccess {
    pub consumed_milligas: Narith,
}

impl Default for TransferSuccess {
    fn default() -> Self {
        Self {
            storage: None,
            balance_updates: vec![],
            ticket_receipt: vec![],
            originated_contracts: vec![],
            consumed_milligas: 0.into(),
            storage_size: 0.into(),
            paid_storage_size_diff: 0.into(),
            allocated_destination_contract: false,
            lazy_storage_diff: None,
        }
    }
}

// An operation error in a Tezos receipt has no specific format
// It should just be encoded as a JSON, so we can't derive
// NomReader and BinWriter if we want to be Tezos compatible
#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct ApplyOperationErrors {
    #[encoding(dynamic, list)]
    pub errors: Vec<ApplyOperationError>,
}

impl From<Vec<ApplyOperationError>> for ApplyOperationErrors {
    fn from(value: Vec<ApplyOperationError>) -> Self {
        ApplyOperationErrors { errors: value }
    }
}

impl From<ApplyOperationError> for ApplyOperationErrors {
    fn from(value: ApplyOperationError) -> Self {
        ApplyOperationErrors {
            errors: vec![value],
        }
    }
}

// Inspired from `operation_result` in `src/proto_alpha/lib_protocol/apply_operation_result.ml`
// Still need to implement Backtracked and Skipped
#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub enum ContentResult<M: OperationKind> {
    Applied(M::Success),
    Failed(ApplyOperationErrors),
    Skipped,
    BackTracked(BacktrackedResult<M>),
}

#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct BacktrackedResult<M: OperationKind> {
    pub errors: Option<()>,
    pub result: M::Success,
}

impl<M: OperationKind> ContentResult<M> {
    pub fn backtrack_if_applied(&mut self) {
        if let ContentResult::Applied(_) = self {
            // Lowkey optimisation: takes the ownership of the content result by replacing
            // the result with Skipped as a place holder
            let current_content_result = std::mem::replace(self, ContentResult::Skipped);
            if let ContentResult::Applied(success) = current_content_result {
                *self = ContentResult::BackTracked(BacktrackedResult {
                    errors: None,
                    result: success,
                });
            }
        }
    }
}

/// A [Balance] updates can be triggered on different target
/// inspired from src/proto_alpha/lib_protocol/receipt_repr.ml
#[derive(PartialEq, Debug, NomReader, BinWriter)]
#[encoding(tags = "u8")]
pub enum Balance {
    #[encoding(tag = 0)]
    Account(Contract),
    // Don't know why but in balance_and_update in receipt_repr.ml,
    // the tag 1 doesn't exist
    #[encoding(tag = 2)]
    BlockFees,
    #[encoding(tag = 11)]
    StorageFees,
}

/// Inspired from update_origin_encoding src/proto_alpha/lib_protocol/receipt_repr.ml
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum UpdateOrigin {
    BlockApplication,
}

/// Depending of the sign of [changes], the balance is credited or debited
/// Inspired from balance_updates_encoding src/proto_alpha/lib_protocol/receipt_repr.ml
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct BalanceUpdate {
    pub balance: Balance,
    pub changes: i64,
    pub update_origin: UpdateOrigin,
}

// Inspired from `Manager_operation_result` case in 'kind contents_result type
// from `src/proto_alpha/lib_protocol/apply_results.ml` file.
// Still need to implement internal_results
#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct OperationResult<M: OperationKind> {
    #[encoding(dynamic, list)]
    pub balance_updates: Vec<BalanceUpdate>,
    pub result: ContentResult<M>,
    #[encoding(dynamic, list)]
    pub internal_operation_results: Vec<InternalOperationSum>,
}

#[derive(PartialEq, Debug, BinWriter, NomReader)]
pub struct InternalContentWithMetadata<M: OperationKind> {
    pub sender: Contract,
    pub nonce: u16,
    pub content: M,
    pub result: ContentResult<M>,
}

// Unlike transfers and originations, there is no event kind in Tezos external operations.
// This structure is only used to build the
// `InternalOperationSum::Event` receipt, so it is intentionally *not* added to
// `sdk/rust/protocol/src/operation.rs`.
//
// Field mapping / encoding notes (Rust/MIR/OCaml):
// - `ty` is `Or<Type, Vec<u8>>` in MIR, and ends up as a Micheline-encoded `Script.expr` in OCaml.
// - `tag` corresponds to `Option<FieldAnnotation<'a>>` in MIR and `Entrypoint.t` in OCaml. We keep
//   it as an `Option` because it is encoded as an `opt` on the OCaml side; when absent on decode,
//   OCaml uses `Entrypoint.is_default`.
// - `payload` corresponds to `TypedValue<'a>` in MIR and a Micheline-encoded `Script.expr` in OCaml.
//   We keep it as an `Option` because it is encoded as an `opt` on the OCaml side; when absent on
//   decode, OCaml uses `Script_repr.unit`.
//
// See: `Event` case in `internal_operation_contents` type and `event_case` value
// in `src/proto_alpha/lib_protocol/apply_internal_results.ml`.
#[derive(PartialEq, Debug, Clone, BinWriter, NomReader)]
pub struct EventContent {
    pub ty: Vec<u8>,
    pub tag: Option<Entrypoint>,
    pub payload: Option<Vec<u8>>,
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum InternalOperationSum {
    #[encoding(tag = 1)]
    Transfer(InternalContentWithMetadata<TransferContent>),
    #[encoding(tag = 2)]
    Origination(InternalContentWithMetadata<OriginationContent>),
    #[encoding(tag = 4)] // tag 3 is for delegation on L1
    Event(InternalContentWithMetadata<EventContent>),
}

impl BalanceUpdate {
    pub fn transfer(sender: Contract, destination: Contract, amount: u64) -> Vec<Self> {
        let sender = Balance::Account(sender);
        let destination = Balance::Account(destination);

        let sender_update = Self {
            balance: sender,
            changes: -(amount as i64),
            update_origin: UpdateOrigin::BlockApplication,
        };
        let destination_update = Self {
            balance: destination,
            changes: amount as i64,
            update_origin: UpdateOrigin::BlockApplication,
        };
        vec![sender_update, destination_update]
    }
}

impl InternalOperationSum {
    pub fn transform_result_backtrack(&mut self) {
        match self {
            InternalOperationSum::Transfer(op_res) => {
                op_res.result.backtrack_if_applied();
            }
            InternalOperationSum::Origination(op_res) => {
                op_res.result.backtrack_if_applied();
            }
            InternalOperationSum::Event(op_res) => {
                op_res.result.backtrack_if_applied();
            }
        }
    }
    pub fn is_applied(&self) -> bool {
        match self {
            InternalOperationSum::Transfer(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            InternalOperationSum::Origination(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            InternalOperationSum::Event(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
        }
    }
}

#[derive(PartialEq, Debug)]
pub enum OperationResultSum {
    Reveal(OperationResult<RevealContent>),
    Transfer(OperationResult<TransferContent>),
    Origination(OperationResult<OriginationContent>),
}

impl OperationResultSum {
    pub fn is_applied(&self) -> bool {
        match self {
            OperationResultSum::Reveal(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            OperationResultSum::Transfer(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
            OperationResultSum::Origination(op_res) => {
                matches!(op_res.result, ContentResult::Applied(_))
            }
        }
    }

    pub fn transform_result_backtrack(&mut self) {
        match self {
            OperationResultSum::Transfer(op_result) => {
                op_result.result.backtrack_if_applied();
            }
            OperationResultSum::Reveal(op_result) => {
                op_result.result.backtrack_if_applied();
            }
            OperationResultSum::Origination(op_result) => {
                op_result.result.backtrack_if_applied();
            }
        }
    }
}

pub fn produce_operation_result<M: OperationKind>(
    balance_updates: Vec<BalanceUpdate>,
    result: Result<M::Success, ApplyOperationError>,
    internal_operation_results: Vec<InternalOperationSum>,
) -> OperationResult<M> {
    match result {
        Ok(success) => {
            let all_internal_succeded = internal_operation_results
                .last()
                .is_none_or(InternalOperationSum::is_applied);
            OperationResult {
                balance_updates,
                result: if all_internal_succeded {
                    ContentResult::Applied(success)
                } else {
                    ContentResult::BackTracked(BacktrackedResult {
                        errors: None,
                        result: success, // If internal operations failed, we backtrack the main operation result
                    })
                },
                internal_operation_results,
            }
        }
        Err(operation_error) => OperationResult {
            balance_updates,
            result: ContentResult::Failed(vec![operation_error].into()),
            internal_operation_results,
        },
    }
}

pub fn produce_skipped_receipt(
    op: ManagerOperation<OperationContent>,
    balance_updates: Vec<BalanceUpdate>,
) -> OperationWithMetadata {
    match &op.operation {
        OperationContent::Reveal(_) => OperationWithMetadata {
            content: op.into_manager_operation_content(),
            receipt: OperationResultSum::Reveal(produce_skipped_result(balance_updates)),
        },
        OperationContent::Transfer(_) => OperationWithMetadata {
            content: op.into_manager_operation_content(),
            receipt: OperationResultSum::Transfer(produce_skipped_result(
                balance_updates,
            )),
        },
        OperationContent::Origination(_) => OperationWithMetadata {
            content: op.into_manager_operation_content(),
            receipt: OperationResultSum::Origination(produce_skipped_result(
                balance_updates,
            )),
        },
    }
}

fn produce_skipped_result<M: OperationKind>(
    balance_updates: Vec<BalanceUpdate>,
) -> OperationResult<M> {
    OperationResult {
        balance_updates,
        result: ContentResult::Skipped,
        internal_operation_results: vec![],
    }
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub enum OperationDataAndMetadata {
    OperationWithMetadata(OperationBatchWithMetadata),
}

#[derive(PartialEq, Debug, NomReader, BinWriter)]
pub struct OperationBatchWithMetadata {
    #[encoding(dynamic, list)]
    pub operations: Vec<OperationWithMetadata>,
    pub signature: UnknownSignature,
}

#[derive(PartialEq, Debug)]
pub struct OperationWithMetadata {
    pub content: ManagerOperationContent,
    pub receipt: OperationResultSum,
}

impl NomReader<'_> for OperationWithMetadata {
    fn nom_read(input: &'_ [u8]) -> tezos_nom::NomResult<'_, Self> {
        let (input, content) = ManagerOperationContent::nom_read(input)?;
        let (input, receipt) = match content {
            ManagerOperationContent::Transaction(_) => {
                let (input, receipt) =
                    OperationResult::<TransferContent>::nom_read(input)?;
                (input, OperationResultSum::Transfer(receipt))
            }
            ManagerOperationContent::Reveal(_) => {
                let (input, receipt) = OperationResult::<RevealContent>::nom_read(input)?;
                (input, OperationResultSum::Reveal(receipt))
            }
            ManagerOperationContent::Origination(_) => {
                let (input, receipt) =
                    OperationResult::<OriginationContent>::nom_read(input)?;
                (input, OperationResultSum::Origination(receipt))
            }
            _ => {
                return Err(nom::Err::Error(tezos_nom::error::DecodeError::invalid_tag(
                    input,
                    format!("{content:?}"),
                )))
            }
        };
        Ok((input, Self { content, receipt }))
    }
}

impl BinWriter for OperationWithMetadata {
    fn bin_write(&self, output: &mut Vec<u8>) -> tezos_enc::BinResult {
        self.content.bin_write(output)?;
        match &self.receipt {
            OperationResultSum::Transfer(receipt) => receipt.bin_write(output),
            OperationResultSum::Reveal(receipt) => receipt.bin_write(output),
            OperationResultSum::Origination(receipt) => receipt.bin_write(output),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::encoding_test_data_helper::test_helpers::fetch_generated_data;
    use crate::operation::{
        ManagerOperation, OriginationContent, Parameters, TransferContent,
    };
    use crate::protocol::TARGET_TEZOS_PROTOCOL;
    use mir::ast::annotations::{Annotation, Annotations, NO_ANNS};
    use mir::ast::micheline::Micheline;
    use mir::ast::Entrypoint;
    use mir::lexer::Prim;
    use pretty_assertions::assert_eq;
    use std::borrow::Cow;
    use typed_arena::Arena;

    fn dummy_failed_operation() -> OperationDataAndMetadata {
        OperationDataAndMetadata::OperationWithMetadata (
                OperationBatchWithMetadata {
                    operations: vec![OperationWithMetadata {
                        content: ManagerOperationContent::Transaction(
                            ManagerOperation {
                                source: PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(),
                                fee: 255.into(),
                                counter: 1.into(),
                                gas_limit: 0.into(),
                                storage_limit: 0.into(),
                                operation: TransferContent {
                                    amount: 27942405962072064.into(),
                                    destination: Contract::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap(),
                                    parameters: Parameters::default(),
                                }
                            }),
                        receipt: OperationResultSum::Transfer(
                                    OperationResult {
                                        balance_updates: vec![],
                                        result: ContentResult::Failed(
                                            vec![
                                                    ApplyOperationError::Transfer(
                                                        TransferError::BalanceTooLow(
                                                            BalanceTooLow {
                                                                contract: Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(),
                                                                balance: 10_u64.into(),
                                                                amount: 21_u64.into()
                                                            }
                                                        )
                                                    ),
                                                    ApplyOperationError::Transfer(
                                                        TransferError::BalanceTooLow(
                                                            BalanceTooLow {
                                                                contract: Contract::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap(),
                                                                balance: 55_u64.into(),
                                                                amount: 1111_u64.into()
                                                            }
                                                        )
                                                    )
                                                ].into()),
                                        internal_operation_results: vec![]
                                    }
                                )
                    }],
                    signature:  UnknownSignature::from_base58_check(
                       "sigvVF2FguUHvZHytQ4AoRn4R6tSMteAt4nEHfYEbwQi3nXa3xvsgE93V1XYL99FYFUAH83iSpcAe7KxGaAeE1tLJ3M2jGJT"
                    ).unwrap(),
                }
            )
    }

    fn dummy_test_result_operation() -> OperationDataAndMetadata {
        OperationDataAndMetadata::OperationWithMetadata (
                 OperationBatchWithMetadata {
                    operations: vec![OperationWithMetadata {
                        content: ManagerOperationContent::Transaction(ManagerOperation { source: PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(), fee: 468.into(), counter: 1.into(), gas_limit: 2169.into(), storage_limit: 0.into(), operation: TransferContent {
                            amount: 42000000.into(),
                            destination: Contract::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap(),
                            parameters: Parameters::default(),
                        } }),
                        receipt: OperationResultSum::Transfer(OperationResult { balance_updates: vec![], result: ContentResult::Applied(
                            TransferTarget::ToContrat(
                            TransferSuccess { storage: None, lazy_storage_diff: None, balance_updates: vec![
                            BalanceUpdate { balance: Balance::Account(Contract::Implicit(PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap())), changes: -42000000,update_origin : UpdateOrigin::BlockApplication },
                            BalanceUpdate { balance: Balance::Account(Contract::Implicit(PublicKeyHash::from_b58check("tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN").unwrap())), changes: 42000000,update_origin : UpdateOrigin::BlockApplication}
                            ], ticket_receipt: vec![], originated_contracts: vec![], consumed_milligas: 2169000.into(), storage_size: 0.into(), paid_storage_size_diff: 0.into(), allocated_destination_contract: false }
                            ))

                        , internal_operation_results: vec![] })
                    }],
                    signature:  UnknownSignature::from_base58_check(
                        "sigPc9gwEse2o5nsicnNeWLjLgoMbEGumXw7PErAkMMa1asXVKRq43RPd7TnUKYwuHmejxEu15XTyV1iKGiaa8akFHK7CCEF"
                    ).unwrap(),
                })
    }

    fn simple_origination_operation() -> OperationDataAndMetadata {
        OperationDataAndMetadata::OperationWithMetadata(
            OperationBatchWithMetadata {
               operations: vec![OperationWithMetadata {
                   content: ManagerOperationContent::Origination(ManagerOperation { source: PublicKeyHash::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap(), fee: 343.into(), counter: 1.into(), gas_limit: 679.into(), storage_limit: 323.into(),
                   operation: OriginationContent {
                    balance: 1000000_u64.into(),
                    delegate: None,
                    /*
                    octez-client convert script "
                              parameter string;
                              storage string;
                              code { CAR; NIL operation; PAIR }
                            " from Michelson to binary
                     */
                    script: crate::operation::Script { code: hex::decode(
                        "02000000170500036805010368050202000000080316053d036d0342",
                    )
                    .unwrap(), storage: hex::decode(
                        "010000000568656c6c6f",
                    )
                    .unwrap() } } }),
                   receipt:
                    OperationResultSum::Origination(
                        OperationResult {
                            balance_updates:vec![BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -343, update_origin: UpdateOrigin::BlockApplication }, BalanceUpdate { balance: Balance::BlockFees , changes: 343, update_origin: UpdateOrigin::BlockApplication }],
                            result: ContentResult::Applied(
                                OriginationSuccess{
                                    balance_updates:vec![
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -11500, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::StorageFees, changes: 11500, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -64250, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::StorageFees, changes: 64250, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx").unwrap()) , changes: -1000000, update_origin: UpdateOrigin::BlockApplication },
                                        BalanceUpdate { balance: Balance::Account(Contract::from_b58check("KT1WcSvmiwJqDUm6cKEFjGVizXVSMujq5Kfe").unwrap()) , changes: 1000000, update_origin: UpdateOrigin::BlockApplication },
                                    ],
                                    originated_contracts:vec![Originated {contract: ContractKt1Hash::from_base58_check("KT1WcSvmiwJqDUm6cKEFjGVizXVSMujq5Kfe").unwrap()}],
                                    consumed_milligas:578755_u64.into(),
                                    storage_size:46_u64.into(),
                                    paid_storage_size_diff:46_u64.into(),
                                    lazy_storage_diff: None,
                                }),
                            internal_operation_results: vec![]
                        })
                    }
               ],
               signature:  UnknownSignature::from_base58_check(
                   "sigjUkDaz4jjfp7EvsPGryCBoGKZ1B3FiAn4kX9adpwmcKUEpobhkNJjbYqjxB1mgBe7wGGGQp4T8MPzithFpbBMCN2L5RUa"
               ).unwrap(),
           })
    }

    #[test]
    fn test_operation_with_metadata_rlp_roundtrip() {
        let operation_and_receipt = dummy_test_result_operation();
        let mut output = vec![];
        operation_and_receipt
            .bin_write(&mut output)
            .expect("Operation with metadata should be encodable");
        let outputcpy = output.clone();
        let (remaining, read_result) = OperationDataAndMetadata::nom_read(&outputcpy)
            .expect("Operation with metadata should be decodable");

        assert_eq!(
            read_result, operation_and_receipt,
            "Roundtrip failed on {:?}",
            read_result
        );
        assert!(
            remaining.is_empty(),
            "There should be no remaining bytes after decoding"
        );
    }

    #[test]
    fn tezos_compatibility_for_successful_operation_with_metadata() {
        let mut output = vec![];
        dummy_test_result_operation()
            .bin_write(output.as_mut())
            .expect("Operation with metadata should be encodable");
        let operation_and_receipt_bytes = fetch_generated_data(
            TARGET_TEZOS_PROTOCOL,
            "operation.data_and_metadata",
            "tez_transfer",
        );

        assert_eq!(output, operation_and_receipt_bytes);
    }

    #[test]
    fn tezos_compatibility_for_successful_origination_with_metadata() {
        let mut output = vec![];
        simple_origination_operation()
            .bin_write(output.as_mut())
            .expect("Operation with metadata should be encodable");
        let operation_and_receipt_bytes = fetch_generated_data(
            TARGET_TEZOS_PROTOCOL,
            "operation.data_and_metadata",
            "origination",
        );

        assert_eq!(output, operation_and_receipt_bytes);
    }

    #[test]
    fn tezos_compatibility_for_failed_operation_with_metadata() {
        let operation = dummy_failed_operation();
        let output = operation
            .to_bytes()
            .expect("Operation with metadata should be encodable");
        let operation_and_receipt_bytes = fetch_generated_data(
            TARGET_TEZOS_PROTOCOL,
            "operation.data_and_metadata",
            "failed",
        );

        assert_eq!(output, operation_and_receipt_bytes);
    }

    #[test]
    fn tezos_compatibility_for_internal_operation_with_metadata() {
        let operation = InternalOperationSum::Transfer(InternalContentWithMetadata {
            content: TransferContent {
                amount: 1000000.into(),
                destination: Contract::from_b58check(
                    "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
                )
                .unwrap(),
                parameters: Parameters::default(),
            },
            sender: Contract::from_b58check("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb")
                .unwrap(),
            nonce: 0,
            result: ContentResult::Applied(TransferTarget::ToContrat(TransferSuccess {
                storage: None,
                lazy_storage_diff: None,
                balance_updates: vec![
                    BalanceUpdate {
                        balance: Balance::Account(
                            Contract::from_b58check(
                                "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
                            )
                            .unwrap(),
                        ),
                        changes: -1000000,
                        update_origin: UpdateOrigin::BlockApplication,
                    },
                    BalanceUpdate {
                        balance: Balance::Account(
                            Contract::from_b58check(
                                "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
                            )
                            .unwrap(),
                        ),
                        changes: 1000000,
                        update_origin: UpdateOrigin::BlockApplication,
                    },
                ],
                ticket_receipt: vec![],
                originated_contracts: vec![],
                consumed_milligas: 100000.into(),
                storage_size: 0.into(),
                paid_storage_size_diff: 0.into(),
                allocated_destination_contract: false,
            })),
        });
        let output = operation
            .to_bytes()
            .expect("Internal operation with metadata should be encodable");
        let operation_and_receipt_bytes = fetch_generated_data(
            TARGET_TEZOS_PROTOCOL,
            "operation.internal_and_metadata",
            "applied",
        );
        assert_eq!(output, operation_and_receipt_bytes);
    }

    #[test]
    fn tezos_compatibility_for_internal_event_with_metadata() {
        let arena = Arena::new();

        let source_bytes =
            hex::decode("00005b9a5d6ff9b553b9fae37b844d7a907d8d59593e").unwrap();

        let payload = Micheline::prim2(
            &arena,
            Prim::Pair,
            Micheline::from(10_i128),
            Micheline::from(source_bytes),
        )
        .encode();

        let add_amount_annots: Annotations =
            Annotations::from([Annotation::Field(Cow::Borrowed("addAmount"))]);
        let source_annots: Annotations =
            Annotations::from([Annotation::Field(Cow::Borrowed("source"))]);

        let ty = Micheline::App(
            Prim::pair,
            arena.alloc_extend([
                Micheline::App(Prim::int, &[], add_amount_annots),
                Micheline::App(Prim::address, &[], source_annots),
            ]),
            NO_ANNS,
        )
        .encode();

        let operation = InternalOperationSum::Event(InternalContentWithMetadata {
            content: EventContent {
                tag: Some(Entrypoint::from_string_unchecked("add".into())),
                payload: Some(payload),
                ty,
            },
            sender: Contract::from_b58check("KT1SHrxmgUojs2hwe4hguExy6BqteeG1rDHi")
                .unwrap(),
            nonce: 0,
            result: ContentResult::Applied(EventSuccess {
                consumed_milligas: 100000.into(),
            }),
        });

        let output = operation
            .to_bytes()
            .expect("Internal operation with metadata should be encodable");

        let expected = fetch_generated_data(
            TARGET_TEZOS_PROTOCOL,
            "operation.internal_and_metadata",
            "event",
        );

        assert_eq!(output, expected);
    }

    #[test]
    fn test_backtracked_encoding() {
        let operation = InternalOperationSum::Transfer(InternalContentWithMetadata {
            content: TransferContent {
                amount: 1000000.into(),
                destination: Contract::from_b58check(
                    "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
                )
                .unwrap(),
                parameters: Parameters::default(),
            },
            sender: Contract::from_b58check("tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb")
                .unwrap(),
            nonce: 0,
            result: ContentResult::BackTracked(BacktrackedResult {
                errors: None,
                result: TransferTarget::ToContrat(TransferSuccess {
                    storage: Some(hex::decode("010000000568656c6c6f").unwrap()),
                    lazy_storage_diff: None,
                    balance_updates: vec![
                        BalanceUpdate {
                            balance: Balance::Account(
                                Contract::from_b58check(
                                    "tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb",
                                )
                                .unwrap(),
                            ),
                            changes: -1000000,
                            update_origin: UpdateOrigin::BlockApplication,
                        },
                        BalanceUpdate {
                            balance: Balance::Account(
                                Contract::from_b58check(
                                    "KT1RJ6PbjHpwc3M5rw5s2Nbmefwbuwbdxton",
                                )
                                .unwrap(),
                            ),
                            changes: 1000000,
                            update_origin: UpdateOrigin::BlockApplication,
                        },
                    ],
                    ticket_receipt: vec![],
                    originated_contracts: vec![],
                    consumed_milligas: 100000.into(),
                    storage_size: 0.into(),
                    paid_storage_size_diff: 0.into(),
                    allocated_destination_contract: false,
                }),
            }),
        });
        let output = operation
            .to_bytes()
            .expect("Internal operation with metadata should be encodable");
        let operation_and_receipt_bytes = fetch_generated_data(
            TARGET_TEZOS_PROTOCOL,
            "operation.internal_and_metadata",
            "backtracked",
        );
        assert_eq!(output, operation_and_receipt_bytes);
    }

    #[test]
    fn test_enc_dec_roundtrip_operation_error() {
        let operation_error =
            ApplyOperationError::Transfer(TransferError::BalanceTooLow(BalanceTooLow {
                contract: Contract::from_b58check("tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx")
                    .unwrap(),
                balance: 10_u64.into(),
                amount: 21_u64.into(),
            }));
        let mut output = vec![];
        operation_error
            .bin_write(&mut output)
            .expect("Operation error should be encodable");
        let outputcpy = output.clone();
        let (remaining, read_result) = ApplyOperationError::nom_read(&outputcpy)
            .expect("Operation error should be decodable");

        // Should be a PastError
        assert!(matches!(read_result, ApplyOperationError::PastError(_)));
        assert_eq!(
            remaining.len(),
            0,
            "There should be no remaining bytes after decoding"
        );

        // Encode the PastError back to bytes and decode it again to check if it's the same
        let mut past_error_bytes = vec![];
        read_result
            .bin_write(&mut past_error_bytes)
            .expect("Past error should be encodable");
        let past_error_bytes_copy = past_error_bytes.clone();
        let (remaining, past_error_read_result) =
            ApplyOperationError::nom_read(&past_error_bytes_copy)
                .expect("Past error should be decodable");

        assert_eq!(
            read_result, past_error_read_result,
            "Past error should be the same after encoding and decoding"
        );
        assert_eq!(
            remaining.len(),
            0,
            "There should be no remaining bytes after decoding the past error"
        );
    }
}
