// SPDX-FileCopyrightText: 2025 Functori <contact@functori.com>
// SPDX-FileCopyrightText: 2025 Nomadic Labs <contact@nomadic-labs.com>
//
// SPDX-License-Identifier: MIT

use crate::{database::PrecompileDatabase, send_outbox_message::Withdrawal};
use database::EtherlinkVMDB;
use helpers::u256_to_le_bytes;
use precompile_provider::EtherlinkPrecompiles;
use revm::context::result::EVMError;
use revm::context::tx::TxEnvBuilder;
use revm::handler::EthFrame;
use revm::{
    context::{
        result::ExecutionResult, transaction::AccessList, BlockEnv, CfgEnv, ContextTr,
        DBErrorMarker, Evm, LocalContext, TxEnv,
    },
    context_interface::block::BlobExcessGasAndPrice,
    handler::instructions::EthInstructions,
    interpreter::interpreter::EthInterpreter,
    primitives::{hardfork::SpecId, Address, Bytes, FixedBytes, TxKind, U256},
    Context, ExecuteCommitEvm, Journal, MainBuilder,
};
use tezos_ethereum::block::BlockConstants;
use tezos_evm_runtime::runtime::Runtime;
use tezos_smart_rollup_host::runtime::RuntimeError;
use thiserror::Error;
use world_state_handler::{account_path, WorldStateHandler};

pub mod precompile_init;
pub mod precompile_provider;
pub mod send_outbox_message;
pub mod world_state_handler;

mod block_storage;
mod code_storage;
mod constants;
mod database;
mod helpers;
mod table;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Runtime error: {0}")]
    Runtime(#[from] RuntimeError),
    #[error("Execution error: {0}")]
    Custom(String),
}

pub(crate) fn custom<E: std::fmt::Display>(e: E) -> Error {
    Error::Custom(e.to_string())
}

impl DBErrorMarker for Error {}

#[derive(Debug, Eq, PartialEq)]
pub struct ExecutionOutcome {
    /// Result of the VM transaction execution.
    /// In particular contains gas used and emitted logs.
    pub result: ExecutionResult,
    /// Withdrawals generated by the transaction. This field will be empty if the
    /// transaction fails (or if the transaction doesn't produce any withdrawals).
    pub withdrawals: Vec<Withdrawal>,
}

fn block_env(block_constants: &BlockConstants) -> Result<BlockEnv, Error> {
    // TODO: Whenever the switch to REVM is completely made, readapt BlockConstants
    // structure to match alloy's type. The current structure is highly dependant
    // on what is needed for Sputnik.
    let basefee: u64 = match block_constants.base_fee_per_gas().try_into() {
        Ok(basefee) => basefee,
        Err(err) => {
            return Err(Error::Custom(format!(
                "Invalid base fee per gas conversion: {err:?}"
            )))
        }
    };
    Ok(BlockEnv {
        number: U256::from_le_slice(&u256_to_le_bytes(block_constants.number)),
        beneficiary: Address::from(block_constants.coinbase.0),
        timestamp: U256::from_le_slice(&u256_to_le_bytes(block_constants.timestamp)),
        gas_limit: block_constants.gas_limit,
        basefee,
        difficulty: U256::ZERO,
        prevrandao: Some(
            block_constants
                .prevrandao
                .map(|prevrandao| FixedBytes(prevrandao.0))
                .unwrap_or_default(),
        ),
        blob_excess_gas_and_price: Some(BlobExcessGasAndPrice::new(0, 1)),
    })
}

#[allow(clippy::too_many_arguments)]
fn tx_env<'a, Host: Runtime>(
    host: &'a mut Host,
    world_state_handler: &'a mut WorldStateHandler,
    caller: Address,
    destination: Option<Address>,
    gas_limit: u64,
    gas_price: u128,
    value: U256,
    data: Bytes,
    access_list: AccessList,
    chain_id: u64,
) -> Result<TxEnv, Error> {
    let kind = match destination {
        Some(address) => TxKind::Call(address),
        None => TxKind::Create,
    };

    let storage_account = world_state_handler
        .get_or_create(host, &account_path(&caller)?)
        .map_err(|err| Error::Custom(err.to_string()))?;
    let nonce = storage_account.nonce(host)?;

    // Using the transaction environment builder helps to
    // derive the transaction type directly from the different
    // fields of the transaction.
    let tx_env = TxEnvBuilder::new()
        .caller(caller)
        .gas_limit(gas_limit)
        .gas_price(gas_price)
        .kind(kind)
        .value(value)
        .data(data)
        .nonce(nonce)
        .chain_id(Some(chain_id))
        .access_list(access_list)
        .build()
        .map_err(|err| {
            Error::Custom(format!(
                "Building the transaction environment failed with: {:?}",
                err
            ))
        })?;

    Ok(tx_env)
}

type EVMInnerContext<'a, Host> =
    Context<&'a BlockEnv, &'a TxEnv, CfgEnv, EtherlinkVMDB<'a, Host>>;

type EvmContext<'a, Host> = Evm<
    EVMInnerContext<'a, Host>,
    (),
    EthInstructions<EthInterpreter, EVMInnerContext<'a, Host>>,
    EtherlinkPrecompiles,
    EthFrame<EthInterpreter>,
>;

fn evm<'a, Host: Runtime>(
    db: EtherlinkVMDB<'a, Host>,
    block: &'a BlockEnv,
    tx: &'a TxEnv,
    precompiles: EtherlinkPrecompiles,
    chain_id: u64,
    spec_id: SpecId,
) -> EvmContext<'a, Host> {
    let cfg = CfgEnv::new().with_chain_id(chain_id).with_spec(spec_id);

    let context: Context<
        BlockEnv,
        TxEnv,
        CfgEnv,
        EtherlinkVMDB<'a, Host>,
        Journal<EtherlinkVMDB<'a, Host>>,
        (),
        LocalContext,
    > = Context::new(db, spec_id);

    let evm = context
        .with_block(block)
        .with_tx(tx)
        .with_cfg(cfg)
        .build_mainnet();

    evm.with_precompiles(precompiles)
}

#[allow(clippy::too_many_arguments)]
pub fn run_transaction<'a, Host: Runtime>(
    host: &'a mut Host,
    spec_id: SpecId,
    block_constants: &'a BlockConstants,
    world_state_handler: &'a mut WorldStateHandler,
    precompiles: EtherlinkPrecompiles,
    caller: Address,
    destination: Option<Address>,
    call_data: Bytes,
    gas_limit: u64,
    effective_gas_price: u128,
    value: U256,
    access_list: AccessList,
) -> Result<ExecutionOutcome, EVMError<Error>> {
    let mut commit_status = true;
    let block_env = block_env(block_constants)?;
    let tx = tx_env(
        host,
        world_state_handler,
        caller,
        destination,
        gas_limit,
        effective_gas_price,
        value,
        call_data,
        access_list,
        block_constants.chain_id.as_u64(),
    )?;

    let db = EtherlinkVMDB::new(
        host,
        block_constants,
        world_state_handler,
        &mut commit_status,
    );

    let mut evm = evm(
        db,
        &block_env,
        &tx,
        precompiles,
        block_constants.chain_id.as_u64(),
        spec_id,
    );

    evm.db_mut().initialize_storage()?;

    let execution_result = evm.transact_commit(&tx)?;

    let withdrawals = evm.db_mut().take_withdrawals();

    if !evm.db_mut().commit_status() {
        // If something went wrong while commiting we drop the state changes
        // made to the durable storage to avoid ending up in inconsistent state.
        evm.db_mut().drop_storage()?;

        return Err(EVMError::Custom(
            "Comitting ended up in an incorrect state change: reverting.".to_owned(),
        ));
    } else {
        evm.db_mut().commit_storage()?;
    }

    Ok(ExecutionOutcome {
        result: execution_result, // contains logs and gas_used.
        withdrawals,
    })
}

#[cfg(test)]
mod test {
    use revm::{
        context::{
            result::{ExecutionResult, Output},
            transaction::AccessList,
        },
        primitives::{hex::FromHex, Address, Bytes, U256},
        state::{AccountInfo, Bytecode},
    };
    use serde_json::Value;
    use tezos_evm_runtime::runtime::MockKernelHost;
    use tezos_smart_rollup_host::runtime::Runtime;
    use utilities::{
        block_constants_with_fees, block_constants_with_no_fees, DEFAULT_SPEC_ID,
    };

    use crate::{
        constants::WITHDRAWAL_SOL_ADDR,
        precompile_init::init_precompile_bytecodes,
        world_state_handler::{new_world_state_handler, WITHDRAWALS_TICKETER_PATH},
    };
    use crate::{
        precompile_provider::EtherlinkPrecompiles, run_transaction,
        world_state_handler::account_path, ExecutionOutcome,
    };

    mod utilities {
        use primitive_types::{H160 as PH160, U256 as PU256};
        use revm::primitives::hardfork::SpecId;
        use tezos_ethereum::block::{BlockConstants, BlockFees};

        // The default SpecId is set to Cancun.
        // It isn't modular like it was in the previous evm execution.
        // This value was normally retrived from the old execution storage. Once we fully
        // make the switch to REVM this part will become modular again.
        // For now we keep it at Cancun which is the latest EVM version Etherlink supports.
        pub(crate) const DEFAULT_SPEC_ID: SpecId = SpecId::CANCUN;
        const ETHERLINK_CHAIN_ID: u64 = 42793;

        pub(crate) fn block_constants_with_fees() -> BlockConstants {
            BlockConstants::first_block(
                PU256::from(1),
                PU256::from(ETHERLINK_CHAIN_ID),
                BlockFees::new(PU256::from(1), PU256::from(1), PU256::from(1)),
                30_000_000,
                PH160::zero(),
            )
        }

        pub(crate) fn block_constants_with_no_fees() -> BlockConstants {
            BlockConstants::first_block(
                PU256::from(1),
                PU256::from(ETHERLINK_CHAIN_ID),
                BlockFees::new(PU256::zero(), PU256::zero(), PU256::zero()),
                30_000_000,
                PH160::zero(),
            )
        }
    }

    #[test]
    fn test_simple_transfer() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_no_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let destination =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();

        let value_sent = U256::from(5);

        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut caller_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        let destination_account = world_state_handler
            .get_or_create(&host, &account_path(&destination).unwrap())
            .unwrap();

        caller_account.set_info(&mut host, caller_info).unwrap();

        // Check balances before executing the transfer
        assert_eq!(caller_account.balance(&host).unwrap(), U256::MAX);
        assert_eq!(destination_account.balance(&host).unwrap(), U256::ZERO);

        let execution_result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            Some(destination),
            Bytes::new(),
            30_000_000,
            0,
            value_sent,
            AccessList(vec![]),
        )
        .unwrap();

        // Check the outcome of the transaction
        match execution_result.result {
            ExecutionResult::Success { .. } => (),
            ExecutionResult::Revert { .. } | ExecutionResult::Halt { .. } => {
                panic!("Simple transfer should have succeeded")
            }
        }

        assert_eq!(
            caller_account.balance(&host).unwrap(),
            U256::MAX.checked_sub(value_sent).unwrap()
        );
        assert_eq!(destination_account.balance(&host).unwrap(), value_sent);
    }

    #[test]
    fn test_contract_call_sload_sstore() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let contract =
            Address::from_hex("2222222222222222222222222222222222222222").unwrap();

        let value_sent = U256::from(5);

        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut caller_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        caller_account.set_info(&mut host, caller_info).unwrap();

        let mut contract_account = world_state_handler
            .get_or_create(&host, &account_path(&contract).unwrap())
            .unwrap();

        let contract_info = AccountInfo {
            balance: U256::ZERO,
            nonce: 0,
            // Code hash will be automatically computed and inserted when
            // inserting the account info into the db.
            code_hash: Default::default(),
            // PUSH1 0x42      # Value to store
            // PUSH1 0x01      # Storage slot index
            // SSTORE          # Store the value in storage
            // PUSH1 0x01      # Load from the same storage slot
            // SLOAD           # Retrieve the value
            code: Some(Bytecode::new_raw(
                Bytes::from_hex("6042600155600154").unwrap(),
            )),
        };

        contract_account.set_info(&mut host, contract_info).unwrap();

        let execution_result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            Some(contract),
            Bytes::new(),
            30_000_000,
            1,
            value_sent,
            AccessList(vec![]),
        )
        .unwrap();

        // Check the outcome of the transaction
        match execution_result.result {
            ExecutionResult::Success { gas_used, .. } => {
                assert!(gas_used > 0);
            }
            ExecutionResult::Revert { .. } | ExecutionResult::Halt { .. } => {
                panic!("Simple transfer should have succeeded")
            }
        }

        // Check that the storage slot at 0x01 was updated with 0x42
        let storage_slot_value =
            contract_account.get_storage(&host, &U256::from(1)).unwrap();

        assert_eq!(storage_slot_value, U256::from(66));
    }

    #[test]
    fn test_contract_deployment() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let precompiles = EtherlinkPrecompiles::new();
        let block_constants = block_constants_with_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        storage_account.set_info(&mut host, caller_info).unwrap();

        let result = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            precompiles,
            caller,
            None,
            // # Deployment code for:
            //
            // pragma solidity ^0.8.0;
            //
            // contract StorageAccess {
            //    uint256 public value = 1;
            //
            //    function setValue(uint256 newValue) public {
            //        value = newValue;
            //    }
            // }
            Bytes::from_hex("6080604052600160005534801561001557600080fd5b50610133806100256000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c80633fa4f24514603757806355241077146051575b600080fd5b603d6069565b604051604891906090565b60405180910390f35b606760048036038101906063919060d5565b606f565b005b60005481565b8060008190555050565b6000819050919050565b608a816079565b82525050565b600060208201905060a360008301846083565b92915050565b600080fd5b60b5816079565b811460bf57600080fd5b50565b60008135905060cf8160ae565b92915050565b60006020828403121560e85760e760a9565b5b600060f48482850160c2565b9150509291505056fea26469706673582212202dba9d4631e2c42eb5a90449e79df9c7031f4e73f695987b580809d987c057c864736f6c63430008120033").unwrap(),
            30_000_000,
            1,
            U256::ZERO,
            AccessList(vec![]),
        );

        match result {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Create(bytecode, Some(address)),
                        ..
                    },
                ..
            }) => {
                let contract_account = world_state_handler
                    .get_or_create(&host, &account_path(&address).unwrap())
                    .unwrap();
                assert_eq!(
                    bytecode,
                    contract_account
                        .code(&host)
                        .unwrap()
                        .unwrap()
                        .original_bytes()
                )
            }
            other => panic!("ERROR: ended up in {other:?}"),
        }
    }

    #[test]
    fn test_withdrawal_contract() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_no_fees();

        init_precompile_bytecodes(&mut host, &mut world_state_handler).unwrap();

        // Insert account information
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };
        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();
        storage_account.set_info(&mut host, caller_info).unwrap();

        // Store the ticketer address required to build the outbox message
        host.store_write_all(
            &WITHDRAWALS_TICKETER_PATH,
            "KT1BjtrJYcknDALNGhUqtdHwbrFW1AcsUJo4".as_bytes(),
        )
        .unwrap();

        // Call the created address with data generated from:
        // $ cast calldata "withdraw_base58(string)" "tz1fp5ncDmqYwYC568fREYz9iwQTgGQuKZqX"

        let calldata = "0xcda4fee200000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000024747a316670356e63446d7159775943353638665245597a3969775154674751754b5a715800000000000000000000000000000000000000000000000000000000";
        let withdrawn_amount = U256::from(1_000_000_000_000u64);

        let ExecutionOutcome {
            result,
            withdrawals,
        } = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(WITHDRAWAL_SOL_ADDR),
            Bytes::from_hex(calldata).unwrap(),
            10_000_000,
            0,
            withdrawn_amount,
            AccessList(vec![]),
        )
        .unwrap();

        // Verify that:
        //  - caller is deducted
        //  - withdrawal contract burned the received amount
        //  - zero address received the burned amound
        //  - outbox message has been built and sent
        assert!(result.is_success());
        assert_eq!(
            storage_account.balance(&host).unwrap(),
            U256::MAX.saturating_sub(withdrawn_amount)
        );
        let created_account = world_state_handler
            .get_or_create(&host, &account_path(&WITHDRAWAL_SOL_ADDR).unwrap())
            .unwrap();
        assert_eq!(created_account.balance(&host).unwrap(), U256::ZERO);
        let zero_account = world_state_handler
            .get_or_create(&host, &account_path(&Address::ZERO).unwrap())
            .unwrap();
        assert_eq!(zero_account.balance(&host).unwrap(), withdrawn_amount);
        let raw_expected_withdrawals = r#"[Standard(AtomicTransactionBatch(OutboxMessageTransactionBatch { batch: [OutboxMessageTransaction { parameters: MichelsonPair(MichelsonContract(Implicit(Ed25519(ContractTz1Hash("tz1fp5ncDmqYwYC568fREYz9iwQTgGQuKZqX")))), Ticket(MichelsonPair(MichelsonContract(Originated(ContractKt1Hash("KT1BjtrJYcknDALNGhUqtdHwbrFW1AcsUJo4"))), MichelsonPair(MichelsonPair(MichelsonNat(Zarith(0)), MichelsonOption(None)), MichelsonInt(Zarith(1)))))), destination: Originated(ContractKt1Hash("KT1BjtrJYcknDALNGhUqtdHwbrFW1AcsUJo4")), entrypoint: Entrypoint { name: "burn" } }] }))]"#;
        assert_eq!(format!("{:?}", withdrawals), raw_expected_withdrawals);
    }

    #[test]
    #[ignore]
    fn create_withdrawal_contract() {
        // TODO: Automate this
        // This test sole purpose is generating the result of a CREATE operation
        // Currently used as a script, do not remove `#[ignore]`

        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_no_fees();

        // TODO: use foundry-compilers here when kernel rust version is bumped to 1.87
        // For the moment if you need to rebuild you can run:
        // $ forge build etherlink/kernel_latest/revm/contracts/withdrawal.sol --out etherlink/kernel_latest/revm/contracts/out

        // Read compiled XTZWithdrawal
        let _file =
            std::fs::read_to_string("contracts/out/withdrawal.sol/XTZWithdrawal.json")
                .unwrap();
        let _file =
            std::fs::read_to_string("contracts/out/fa_withdrawal.sol/FAWithdrawal.json")
                .unwrap();
        let file = std::fs::read_to_string(
            "contracts/out/internal_forwarder.sol/InternalForwarder.json",
        )
        .unwrap();
        let json: Value = serde_json::from_str(&file).unwrap();
        let hex = json["bytecode"]["object"].as_str().unwrap();
        let deployed = Bytes::from_hex(hex).unwrap();

        // Insert account information
        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };
        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();
        storage_account.set_info(&mut host, caller_info).unwrap();

        // Deploy XTZWithdrawal
        let ExecutionOutcome { result, .. } = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            None,
            deployed,
            10_000_000,
            0,
            U256::ZERO,
            AccessList(vec![]),
        )
        .unwrap();

        // Read and display the written bytecode
        assert!(result.is_success());
        let created_address = result.created_address().unwrap();
        let created_account = world_state_handler
            .get_or_create(&host, &account_path(&created_address).unwrap())
            .unwrap();
        let code = created_account.code(&host).unwrap();
        println!("Create output = {:?}", code.clone());
    }

    #[test]
    fn test_call_mint_erc20() {
        let mut host = MockKernelHost::default();
        let mut world_state_handler = new_world_state_handler().unwrap();
        let block_constants = block_constants_with_fees();

        let caller =
            Address::from_hex("1111111111111111111111111111111111111111").unwrap();
        let caller_info = AccountInfo {
            balance: U256::MAX,
            nonce: 0,
            code_hash: Default::default(),
            code: None,
        };

        let mut storage_account = world_state_handler
            .get_or_create(&host, &account_path(&caller).unwrap())
            .unwrap();

        storage_account.set_info(&mut host, caller_info).unwrap();

        let result_create = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            None,
            // # Deployment code for: Tasuku Nakamura's IERC20's contract.
            Bytes::from_hex("60806040526040518060400160405280601381526020017f536f6c6964697479206279204578616d706c6500000000000000000000000000815250600390816200004a91906200033c565b506040518060400160405280600781526020017f534f4c4259455800000000000000000000000000000000000000000000000000815250600490816200009191906200033c565b506012600560006101000a81548160ff021916908360ff160217905550348015620000bb57600080fd5b5062000423565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b600060028204905060018216806200014457607f821691505b6020821081036200015a5762000159620000fc565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b600060088302620001c47fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8262000185565b620001d0868362000185565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b60006200021d620002176200021184620001e8565b620001f2565b620001e8565b9050919050565b6000819050919050565b6200023983620001fc565b62000251620002488262000224565b84845462000192565b825550505050565b600090565b6200026862000259565b620002758184846200022e565b505050565b5b818110156200029d57620002916000826200025e565b6001810190506200027b565b5050565b601f821115620002ec57620002b68162000160565b620002c18462000175565b81016020851015620002d1578190505b620002e9620002e08562000175565b8301826200027a565b50505b505050565b600082821c905092915050565b60006200031160001984600802620002f1565b1980831691505092915050565b60006200032c8383620002fe565b9150826002028217905092915050565b6200034782620000c2565b67ffffffffffffffff811115620003635762000362620000cd565b5b6200036f82546200012b565b6200037c828285620002a1565b600060209050601f831160018114620003b457600084156200039f578287015190505b620003ab85826200031e565b8655506200041b565b601f198416620003c48662000160565b60005b82811015620003ee57848901518255600182019150602085019450602081019050620003c7565b868310156200040e57848901516200040a601f891682620002fe565b8355505b6001600288020188555050505b505050505050565b610d6a80620004336000396000f3fe608060405234801561001057600080fd5b50600436106100a95760003560e01c806342966c681161007157806342966c681461016857806370a082311461018457806395d89b41146101b4578063a0712d68146101d2578063a9059cbb146101ee578063dd62ed3e1461021e576100a9565b806306fdde03146100ae578063095ea7b3146100cc57806318160ddd146100fc57806323b872dd1461011a578063313ce5671461014a575b600080fd5b6100b661024e565b6040516100c391906109be565b60405180910390f35b6100e660048036038101906100e19190610a79565b6102dc565b6040516100f39190610ad4565b60405180910390f35b6101046103ce565b6040516101119190610afe565b60405180910390f35b610134600480360381019061012f9190610b19565b6103d4565b6040516101419190610ad4565b60405180910390f35b610152610585565b60405161015f9190610b88565b60405180910390f35b610182600480360381019061017d9190610ba3565b610598565b005b61019e60048036038101906101999190610bd0565b61066f565b6040516101ab9190610afe565b60405180910390f35b6101bc610687565b6040516101c991906109be565b60405180910390f35b6101ec60048036038101906101e79190610ba3565b610715565b005b61020860048036038101906102039190610a79565b6107ec565b6040516102159190610ad4565b60405180910390f35b61023860048036038101906102339190610bfd565b610909565b6040516102459190610afe565b60405180910390f35b6003805461025b90610c6c565b80601f016020809104026020016040519081016040528092919081815260200182805461028790610c6c565b80156102d45780601f106102a9576101008083540402835291602001916102d4565b820191906000526020600020905b8154815290600101906020018083116102b757829003601f168201915b505050505081565b600081600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040516103bc9190610afe565b60405180910390a36001905092915050565b60005481565b600081600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104629190610ccc565b9250508190555081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546104b89190610ccc565b9250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461050e9190610d00565b925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516105729190610afe565b60405180910390a3600190509392505050565b600560009054906101000a900460ff1681565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546105e79190610ccc565b92505081905550806000808282546105ff9190610ccc565b92505081905550600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516106649190610afe565b60405180910390a350565b60016020528060005260406000206000915090505481565b6004805461069490610c6c565b80601f01602080910402602001604051908101604052809291908181526020018280546106c090610c6c565b801561070d5780601f106106e25761010080835404028352916020019161070d565b820191906000526020600020905b8154815290600101906020018083116106f057829003601f168201915b505050505081565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546107649190610d00565b925050819055508060008082825461077c9190610d00565b925050819055503373ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040516107e19190610afe565b60405180910390a350565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461083d9190610ccc565b9250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546108939190610d00565b925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040516108f79190610afe565b60405180910390a36001905092915050565b6002602052816000526040600020602052806000526040600020600091509150505481565b600081519050919050565b600082825260208201905092915050565b60005b8381101561096857808201518184015260208101905061094d565b60008484015250505050565b6000601f19601f8301169050919050565b60006109908261092e565b61099a8185610939565b93506109aa81856020860161094a565b6109b381610974565b840191505092915050565b600060208201905081810360008301526109d88184610985565b905092915050565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000610a10826109e5565b9050919050565b610a2081610a05565b8114610a2b57600080fd5b50565b600081359050610a3d81610a17565b92915050565b6000819050919050565b610a5681610a43565b8114610a6157600080fd5b50565b600081359050610a7381610a4d565b92915050565b60008060408385031215610a9057610a8f6109e0565b5b6000610a9e85828601610a2e565b9250506020610aaf85828601610a64565b9150509250929050565b60008115159050919050565b610ace81610ab9565b82525050565b6000602082019050610ae96000830184610ac5565b92915050565b610af881610a43565b82525050565b6000602082019050610b136000830184610aef565b92915050565b600080600060608486031215610b3257610b316109e0565b5b6000610b4086828701610a2e565b9350506020610b5186828701610a2e565b9250506040610b6286828701610a64565b9150509250925092565b600060ff82169050919050565b610b8281610b6c565b82525050565b6000602082019050610b9d6000830184610b79565b92915050565b600060208284031215610bb957610bb86109e0565b5b6000610bc784828501610a64565b91505092915050565b600060208284031215610be657610be56109e0565b5b6000610bf484828501610a2e565b91505092915050565b60008060408385031215610c1457610c136109e0565b5b6000610c2285828601610a2e565b9250506020610c3385828601610a2e565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680610c8457607f821691505b602082108103610c9757610c96610c3d565b5b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000610cd782610a43565b9150610ce283610a43565b9250828203905081811115610cfa57610cf9610c9d565b5b92915050565b6000610d0b82610a43565b9150610d1683610a43565b9250828201905080821115610d2e57610d2d610c9d565b5b9291505056fea264697066735822122066c43ea8566df927073ea47efbfa7f9ed97ebc53ac46b1f05dd52d5af93b50be64736f6c63430008120033").unwrap(),
            30_000_000,
            1,
            U256::ZERO,
            AccessList(vec![]),
        );

        let contract_address = match result_create {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Create(_, Some(address)),
                        ..
                    },
                ..
            }) => address,
            other => panic!("ERROR: ended up in {other:?}"),
        };

        let result_call = run_transaction(
            &mut host,
            DEFAULT_SPEC_ID,
            &block_constants,
            &mut world_state_handler,
            EtherlinkPrecompiles::new(),
            caller,
            Some(contract_address),
            // # Call data for: Tasuku Nakamura's IERC20's contract 'mint(uint256)' entrypoint.
            Bytes::from_hex("a0712d68000000000000000000000000000000000000000000000000000000000000002a").unwrap(),
            30_000_000,
            1,
            U256::ZERO,
            AccessList(vec![]),
        );

        match result_call {
            Ok(ExecutionOutcome {
                result:
                    ExecutionResult::Success {
                        output: Output::Call(_),
                        ..
                    },
                ..
            }) => (),
            other => panic!("ERROR: ended up in {other:?}"),
        };
    }
}
